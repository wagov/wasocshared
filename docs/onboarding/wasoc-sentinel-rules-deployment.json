{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "Workspace": {
      "type": "string",
      "metadata": {
        "description": "The Microsoft Sentinel workspace into which the ASIM functions and Analytics Rules will be deployed. Has to be in the selected Resource Group."
      }
    },
    "WorkspaceRegion": {
      "type": "string",
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "The region of the selected workspace. The default value will use the Region selection above (this shouldn't need to be changed)."
      }
    }
  },
  "resources": [
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2021-04-01",
      "name": "ASimFullDeployment",
      "properties": {
        "mode": "Incremental",
        "templateLink": {
          "uri": "https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/ASIM/ASimFullDeployment.json",
          "contentVersion": "1.0.0.0"
        },
        "parameters": {
          "Workspace": {
            "value": "[parameters('Workspace')]"
          },
          "WorkspaceRegion": {
            "value": "[parameters('WorkspaceRegion')]"
          }
        }
      }
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2021-04-01",
      "name": "AnalyticsRules",
      "dependsOn": [
        "ASimFullDeployment"
      ],
      "properties": {
        "mode": "Incremental",
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "resources": [
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/3d411de5-bba0-4c82-8d5d-992fb947539d')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "02ef8d7e-fc3a-4d86-a457-650fa571d8d2",
                "description": "Identifies when a user account successfully logs onto an Azure App from one IP and within 10 mins failed to logon to the same App via a different IP.\nThis may indicate a malicious attempt at password guessing based on knowledge of the users account.",
                "displayName": "Successful logon from IP and failure from a different IP",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SuccessIPAddress",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "FailedIPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let logonDiff = 10m;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where ResultType == \"0\"\n| where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\") // To remove false-positives, add more Apps to this array\n| project SuccessLogonTime = TimeGenerated, UserPrincipalName, SuccessIPAddress = IPAddress, AppDisplayName, SuccessIPBlock = strcat(split(IPAddress, \".\")[0], \".\", split(IPAddress, \".\")[1]), Type\n| join kind= inner (\n    table(tableName)\n    | where ResultType !in (\"0\", \"50140\")\n    | where ResultDescription !~ \"Other\"\n    | where AppDisplayName !in (\"Office 365 Exchange Online\", \"Skype for Business Online\") // To remove false-positives, add more Apps to this array\n    | project FailedLogonTime = TimeGenerated, UserPrincipalName, FailedIPAddress = IPAddress, AppDisplayName, ResultType, ResultDescription, Type\n) on UserPrincipalName, AppDisplayName\n| where SuccessLogonTime < FailedLogonTime and FailedLogonTime - SuccessLogonTime <= logonDiff and FailedIPAddress !startswith SuccessIPBlock\n| summarize FailedLogonTime = max(FailedLogonTime), SuccessLogonTime = max(SuccessLogonTime) by UserPrincipalName, SuccessIPAddress, AppDisplayName, FailedIPAddress, ResultType, ResultDescription, Type\n| extend timestamp = SuccessLogonTime\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess",
                  "InitialAccess"
                ],
                "techniques": [
                  "T1110",
                  "T1078"
                ],
                "templateVersion": "1.1.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/74302aac-cd4c-417f-a2a4-c0764bc4b37a')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "56f3f35c-3aca-4437-a1fb-b7a84dc4af00",
                "description": "This detection looks for the steps required to conduct a UAC bypass using Fodhelper.exe. By default this detection looks for the setting of the required registry keys and the invoking of the process within 1 hour - this can be tweaked as required.",
                "displayName": "Potential Fodhelper UAC Bypass",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "Computer",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Account",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityEvent\n  | where EventID == 4657\n  | parse ObjectName with \"\\\\REGISTRY\\\\\" KeyPrefix \"\\\\\" RegistryKey\n  | project-reorder RegistryKey\n  | where RegistryKey has \"Software\\\\Classes\\\\ms-settings\\\\shell\\\\open\\\\command\"\n  | extend TimeKey = bin(TimeGenerated, 1h)\n  | join (\n  SecurityEvent\n  | where EventID == 4688\n  | where Process =~ \"fodhelper.exe\"\n  | where ParentProcessName endswith \"cmd.exe\" or ParentProcessName endswith \"powershell.exe\" or ParentProcessName endswith \"powershell_ise.exe\"\n  | extend TimeKey = bin(TimeGenerated, 1h)) on TimeKey, Computer",
                "queryFrequency": "PT2H",
                "queryPeriod": "PT2H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "PrivilegeEscalation"
                ],
                "techniques": [
                  "T1548"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/928fa73f-b295-4357-91f9-78d6379264fa')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "fb7ca1c9-e14c-40a3-856e-28f3c14ea1ba",
                "description": "This query detects when there is a spike in Azure AD Seamless SSO errors. They may not be caused by a Password Spray attack, but the cause of the errors might need to be investigated.\nAzure AD only logs the requests that matched existing accounts, thus there might have been unlogged requests for non-existing accounts.",
                "displayName": "Password spray attack against Azure AD Seamless SSO",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let account_threshold = 5;\nAADNonInteractiveUserSignInLogs\n//| where ResultType == \"81016\"\n| where ResultType startswith \"81\"\n| summarize DistinctAccounts = dcount(UserPrincipalName), DistinctAddresses = make_set(IPAddress,100) by ResultType\n| where DistinctAccounts > account_threshold\n| mv-expand IPAddress = DistinctAddresses\n| extend IPAddress = tostring(IPAddress)\n| join kind=leftouter (union isfuzzy=true SigninLogs, AADNonInteractiveUserSignInLogs) on IPAddress\n| summarize\n    StartTime = min(TimeGenerated),\n    EndTime = max(TimeGenerated),\n    UserPrincipalName = make_set(UserPrincipalName,100),\n    UserAgent = make_set(UserAgent,100),\n    ResultDescription = take_any(ResultDescription),\n    ResultSignature = take_any(ResultSignature)\n    by IPAddress, Type, ResultType\n| project Type, StartTime, EndTime, IPAddress, ResultType, ResultDescription, ResultSignature, UserPrincipalName, UserAgent = iff(array_length(UserAgent) == 1, UserAgent[0], UserAgent)\n| extend Name = tostring(split(UserPrincipalName[0],'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName[0],'@',1)[0])",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1110"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/37f068ad-9155-4afe-a1fd-09a377aadf81')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "75ea5c39-93e5-489b-b1e1-68fa6c9d2d04",
                "description": "Identifies failed attempts to sign in to disabled accounts across multiple Azure Applications.\nDefault threshold for Azure Applications attempted to sign in to is 3.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50057 - User account is disabled. The account has been disabled by an administrator.",
                "displayName": "Attempts to sign in to disabled accounts",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threshold = 3;\nlet aadFunc = (tableName:string){\ntable(tableName)\n| where ResultType == \"50057\"\n| where ResultDescription =~ \"User account is disabled. The account has been disabled by an administrator.\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), applicationCount = dcount(AppDisplayName),\napplicationSet = make_set(AppDisplayName), count() by UserPrincipalName, IPAddress, Type\n| where applicationCount >= threshold\n| extend timestamp = StartTime, Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/ba72a613-6aab-4fb9-9fee-b3f37ea61662')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "ed43bdb7-eaab-4ea4-be52-6951fcfa7e3b",
                "description": "This query generates the baseline pattern of cloud resource deletions by an individual and generates an anomaly when any unusual spike is detected. These anomalies from unusual or privileged users could be an indication of a cloud infrastructure takedown by an adversary.",
                "displayName": "Mass Cloud resource deletions Time Series Anomaly",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      },
                      {
                        "columnName": "AadUserId",
                        "identifier": "AadUserId"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let starttime = 14d;\nlet endtime = 1d;\nlet timeframe = 1d;\nlet TotalEventsThreshold = 25;\nlet TimeSeriesData = AzureActivity \n| where TimeGenerated between (startofday(ago(starttime))..startofday(now())) \n| where OperationNameValue endswith \"delete\" \n| project TimeGenerated, Caller \n| make-series Total = count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by Caller;\nTimeSeriesData \n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 3, -1, 'linefit') \n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long) \n| where TimeGenerated >= startofday(ago(endtime)) \n| where anomalies > 0 \n| project Caller, TimeGenerated, Total, baseline, anomalies, score \n| where Total > TotalEventsThreshold and baseline > 0 \n| join (AzureActivity \n| where TimeGenerated > startofday(ago(endtime)) \n| where OperationNameValue endswith \"delete\" \n| summarize count(), make_set(OperationNameValue,100), make_set(_ResourceId,100) by bin(TimeGenerated, timeframe), Caller ) on TimeGenerated, Caller \n| extend Name = iif(Caller has '@',tostring(split(Caller,'@',0)[0]),\"\")\n| extend UPNSuffix = iif(Caller has '@',tostring(split(Caller,'@',1)[0]),\"\")\n| extend AadUserId = iif(Caller !has '@',Caller,\"\")",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [
                  "T1485"
                ],
                "templateVersion": "2.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/a28d75af-1cee-4542-9957-53d547aa925e')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "d7c575b2-84f5-48cb-92c5-70d7e8246284",
                "description": "Identifies when Exchange Online transport rule configured to forward emails.\nThis could be an adversary mailbox configured to collect mail from multiple user accounts.",
                "displayName": "Threat Essentials - Mail redirect via ExO transport rule",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "\nOfficeActivity\n| where OfficeWorkload == \"Exchange\"\n| where Operation in~ (\"New-TransportRule\", \"Set-TransportRule\")\n| extend p = parse_json(Parameters)\n| extend RuleName = case(\n  Operation =~ \"Set-TransportRule\", tostring(OfficeObjectId),\n  Operation =~ \"New-TransportRule\", tostring(p[1].Value),\n  \"Unknown\"\n  ) \n| mvexpand p\n| where (p.Name =~ \"BlindCopyTo\" or p.Name =~ \"RedirectMessageTo\") and isnotempty(p.Value)\n| extend RedirectTo = p.Value\n| extend ClientIPOnly = case( \n  ClientIP has \".\" and ClientIP has \":\", tostring(split(ClientIP,\":\")[0]), \n  ClientIP has \".\" and ClientIP has \"-\", tostring(split(ClientIP,\"-\")[0]), \n  ClientIP has \"[\", tostring(trim_start(@'[[]',tostring(split(ClientIP,\"]\")[0]))),\n  ClientIP\n  )  \n| extend Port = case(\n  ClientIP has \".\" and ClientIP has \":\", (split(ClientIP,\":\")[1]),\n  ClientIP has \".\" and ClientIP has \"-\", (split(ClientIP,\"-\")[1]),\n  ClientIP has \"[\" and ClientIP has \":\", tostring(split(ClientIP,\"]:\")[1]),\n  ClientIP has \"[\" and ClientIP has \"-\", tostring(split(ClientIP,\"]-\")[1]),\n  ClientIP\n  )\n| extend ClientIP = ClientIPOnly\n| project TimeGenerated, RedirectTo, ClientIP, Port, UserId, Operation, RuleName\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = ClientIP \n",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Collection",
                  "Exfiltration"
                ],
                "techniques": [],
                "templateVersion": "1.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/ac8b2b3e-2e0e-415d-8f73-7a25dbe4790f')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "5dd76a87-9f87-4576-bab3-268b0e2b338b",
                "description": "Identifies if the number of documents uploaded or downloaded from device(s) associated\nwith a previously unseen user agent exceeds a threshold (default is 5).",
                "displayName": "SharePointFileOperation via devices with previously unseen user agents",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "UserIdName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UserIdUPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "ClientIP",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Site_Url",
                        "identifier": "Url"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threshold = 5;\nlet szSharePointFileOperation = \"SharePointFileOperation\";\nlet szOperations = dynamic([\"FileDownloaded\", \"FileUploaded\"]);\nlet starttime = 8d;\nlet endtime = 1d;\nlet historicalActivity =\nOfficeActivity\n| where TimeGenerated between(ago(starttime)..ago(endtime))\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| where isnotempty(UserAgent)\n| summarize historicalCount = count() by UserAgent, RecordType, Operation;\nlet recentActivity = OfficeActivity\n| where TimeGenerated > ago(endtime)\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| where isnotempty(UserAgent)\n| summarize recentCount = count() by UserAgent, RecordType, Operation;\nlet RareUserAgent = recentActivity | join kind = leftanti (historicalActivity) on UserAgent\n| order by recentCount desc, UserAgent\n// More than 5 downloads/uploads from a new user agent today\n| where recentCount > threshold;\nOfficeActivity\n| where TimeGenerated > ago(endtime)\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| where isnotempty(UserAgent)\n| join kind= inner (RareUserAgent)\non UserAgent, RecordType, Operation\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), OfficeObjectIdCount = dcount(OfficeObjectId), OfficeObjectIdList = make_set(OfficeObjectId) \nby RecordType, Operation, UserAgent, UserType, UserId, ClientIP, OfficeWorkload, Site_Url, UserAgentSeenCount = recentCount\n| extend UserIdName = tostring(split(UserId, '@')[0]), UserIdUPNSuffix = tostring(split(UserId, '@')[1])\n| project-reorder StartTime, EndTime, UserAgent, UserAgentSeenCount, UserId, ClientIP, Site_Url\n| order by UserAgentSeenCount desc, UserAgent asc, UserId asc, Site_Url asc",
                "queryFrequency": "P1D",
                "queryPeriod": "P8D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Exfiltration"
                ],
                "techniques": [
                  "T1030"
                ],
                "templateVersion": "2.2.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/50c7012f-80c5-4f73-87ea-e06298d767e4')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "3a9d5ede-2b9d-43a2-acc4-d272321ff77c",
                "description": " Identifies spike in failed sign-ins from user accounts due to conditional access policied.\nSpike is determined based on Time series anomaly which will look at historical baseline values.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins",
                "displayName": "User Accounts - Sign in Failure due to CA Spikes",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let starttime = 14d;\nlet timeframe = 1d;\nlet scorethreshold = 3;\nlet baselinethreshold = 50;\nlet aadFunc = (tableName:string){\n  // Failed Signins attempts with reasoning related to conditional access policies.\n  table(tableName)\n  | where TimeGenerated between (startofday(ago(starttime))..startofday(now()))\n  | where ResultDescription has_any (\"conditional access\", \"CA\") or ResultType in (50005, 50131, 53000, 53001, 53002, 52003, 70044)\n  | extend UserPrincipalName = tolower(UserPrincipalName)\n  | extend timestamp = TimeGenerated, AccountCustomEntity = UserPrincipalName\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nlet allSignins = union isfuzzy=true aadSignin, aadNonInt;\nlet TimeSeriesAlerts = \nallSignins\n| make-series DailyCount=count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step 1d by UserPrincipalName\n| extend (anomalies, score, baseline) = series_decompose_anomalies(DailyCount, scorethreshold, -1, 'linefit')\n| mv-expand DailyCount to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long)\n// Filtering low count events per baselinethreshold\n| where anomalies > 0 and baseline > baselinethreshold\n| extend AnomalyHour = TimeGenerated\n| project UserPrincipalName, AnomalyHour, TimeGenerated, DailyCount, baseline, anomalies, score;\n// Filter the alerts for specified timeframe\nTimeSeriesAlerts\n| where TimeGenerated > startofday(ago(timeframe))\n| join kind=inner ( \n  allSignins\n  | where TimeGenerated > startofday(ago(timeframe))\n  // create a new column and round to hour\n  | extend DateHour = bin(TimeGenerated, 1h)\n  | summarize PartialFailedSignins = count(), LatestAnomalyTime = arg_max(TimeGenerated, *) by bin(TimeGenerated, 1h), OperationName, Category, ResultType, ResultDescription, UserPrincipalName, UserDisplayName, AppDisplayName, ClientAppUsed, IPAddress, ResourceDisplayName\n) on UserPrincipalName, $left.AnomalyHour == $right.DateHour\n| project LatestAnomalyTime, OperationName, Category, UserPrincipalName, UserDisplayName, ResultType, ResultDescription, AppDisplayName, ClientAppUsed, UserAgent, IPAddress, Location, AuthenticationRequirement, ConditionalAccessStatus, ResourceDisplayName, PartialFailedSignins, TotalFailedSignins = DailyCount, baseline, anomalies, score\n| extend timestamp = LatestAnomalyTime, Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/000f55ab-c2b9-4899-a58c-01d13684579c')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "3fe3c520-04f1-44b8-8398-782ed21435f8",
                "description": "Identifies IP addresses performing DNS lookups associated with common ToR proxies.\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema",
                "displayName": "DNS events related to ToR proxies  (ASIM DNS Schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let torProxies=dynamic([\"tor2web.org\", \"tor2web.com\", \"torlink.co\", \"onion.to\", \"onion.ink\", \"onion.cab\", \"onion.nu\", \"onion.link\", \n\"onion.it\", \"onion.city\", \"onion.direct\", \"onion.top\", \"onion.casa\", \"onion.plus\", \"onion.rip\", \"onion.dog\", \"tor2web.fi\", \n\"tor2web.blutmagie.de\", \"onion.sh\", \"onion.lu\", \"onion.pet\", \"t2w.pw\", \"tor2web.ae.org\", \"tor2web.io\", \"tor2web.xyz\", \"onion.lt\", \n\"s1.tor-gateways.de\", \"s2.tor-gateways.de\", \"s3.tor-gateways.de\", \"s4.tor-gateways.de\", \"s5.tor-gateways.de\", \"hiddenservice.net\"]);\n_Im_Dns(domain_has_any=torProxies)\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Dvc",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Low",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Exfiltration"
                ],
                "techniques": [
                  "T1048"
                ],
                "templateVersion": "1.3.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/ad34c0ae-6fff-4cae-b168-c55691f2a65c')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "3533f74c-9207-4047-96e2-0eb9383be587",
                "description": "This will alert when a user consents to provide a previously-unknown Azure application with offline access via OAuth.\nOffline access will provide the Azure App with access to the listed resources without requiring two-factor authentication.\nConsent to applications with offline access and read capabilities should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.",
                "displayName": "Suspicious application consent for offline access",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "GrantIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"offline\"\n| mv-apply TargetResource=TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend ModifiedProperties = TargetResource.modifiedProperties,\n               AppDisplayName = tostring(TargetResource.displayName),\n               AppClientId = tolower(tostring(TargetResource.id))\n  )\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| mv-apply Properties=ModifiedProperties on \n  (\n      where Properties.displayName =~ \"ConsentAction.Permissions\"\n      | extend ConsentFull = tostring(Properties.newValue)\n      | extend ConsentFull = trim(@'\"',tostring(ConsentFull))\n  )\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull has \"offline_access\" and ConsentFull has_any (\"Files.Read\", \"Mail.Read\", \"Notes.Read\", \"ChannelMessage.Read\", \"Chat.Read\", \"TeamsActivity.Read\", \"Group.Read\", \"EWS.AccessAsUser.All\", \"EAS.AccessAsUser.All\")\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantIpAddress = tostring(iff(isnotempty(InitiatedBy.user.ipAddress), InitiatedBy.user.ipAddress, InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = tostring(iff(isnotempty(InitiatedBy.user.userPrincipalName),InitiatedBy.user.userPrincipalName, InitiatedBy.app.displayName))\n| extend GrantUserAgent = tostring(iff(AdditionalDetails[0].key =~ \"User-Agent\", AdditionalDetails[0].value, \"\"))\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n| mv-apply TargetResource=TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend ModifiedProperties = TargetResource.modifiedProperties,\n               AppClientId = tolower(TargetResource.id)\n  )\n| mv-apply ModifiedProperties=TargetResource.modifiedProperties on \n   (\n      where ModifiedProperties.displayName =~ \"AppAddress\" and ModifiedProperties.newValue has \"AddressType\"\n      | extend AppReplyURLs = ModifiedProperties.newValue\n   )\n | distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n | mv-apply TargetResource=TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n      | extend GrantAuthentication = tostring(TargetResource.displayName)\n  )\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend timestamp = TimeGenerated, Name = tostring(split(GrantInitiatedBy,'@',0)[0]), UPNSuffix = tostring(split(GrantInitiatedBy,'@',1)[0])",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Low",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1528"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/ad0bd28b-7d25-45ab-bdbb-45d797af1869')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "eeb11b6b-e626-4228-b74d-3e730dca8999",
                "description": "This alert is designed to monitor data connector configurations. This alert is triggered when a data connector is added, updated, or deleted.",
                "displayName": "M2131_DataConnectorAddedChangedRemoved",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "AzureResource",
                    "fieldMappings": [
                      {
                        "columnName": "ResourceId",
                        "identifier": "ResourceId"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AzureActivity\n| where OperationNameValue contains \"Microsoft.SecurityInsights/dataConnectors/\"\n| where ActivityStatusValue == \"Succeeded\"\n| project OperationNameValue, Caller, CallerIpAddress, ActivityStatusValue, ActivitySubstatusValue, ResourceGroup, Properties, ResourceId, TimeGenerated\n| sort by TimeGenerated desc\n| extend Account = Caller\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Discovery"
                ],
                "techniques": [
                  "T1082"
                ],
                "templateVersion": "1.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/80ebdfb0-1528-4886-96b8-1295fc316671')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "faf1a6ff-53b5-4f92-8c55-4b20e9957594",
                "description": "This query uses Windows Event ID 5136 in order to detect potential webshell deployment by exploitation of CVE-2021-27065.\nThis query looks for changes to the InternalHostName or ExternalHostName properties of Exchange OAB Virtual Directory objects in AD Directory Services\nwhere the new objects contain potential webshell objects. Ref: https://aka.ms/ExchangeVulns",
                "displayName": "Exchange OAB Virtual Directory Attribute Containing Potential Webshell",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityEvent\n// Look for specific Directory Service Changes and parse data\n| where EventID == 5136\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion = array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value),TimeGenerated, EventID, Computer, Account, AccountType, EventSourceName, Activity, SubjectAccount)\n// Where changes relate to Exchange OAB\n| extend ObjectClass = column_ifexists(\"ObjectClass\", \"\")\n| where ObjectClass =~ \"msExchOABVirtualDirectory\"\n// Look for InternalHostName or ExternalHostName properties being changed\n| extend AttributeLDAPDisplayName = column_ifexists(\"AttributeLDAPDisplayName\", \"\")\n| where AttributeLDAPDisplayName in~ (\"msExchExternalHostName\", \"msExchInternalHostName\")\n// Look for suspected webshell activity\n| extend AttributeValue = column_ifexists(\"AttributeValue\", \"\")\n| where AttributeValue has \"script\"\n| project-rename LastSeen = TimeGenerated\n| extend ObjectDN = column_ifexists(\"ObjectDN\", \"\")\n| project-reorder LastSeen, Computer, Account, ObjectDN, AttributeLDAPDisplayName, AttributeValue\n| extend timestamp = LastSeen, AccountCustomEntity = Account, HostCustomEntity = Computer",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1190"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/a3959db6-aa01-45f3-8978-f90ae1aeac5a')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "(MDIoT) {{Description}}",
                  "alertDisplayNameFormat": "(MDIoT) {{AlertName}}",
                  "alertSeverityColumnName": "AlertSeverity",
                  "alertTacticsColumnName": "Tactics"
                },
                "alertRuleTemplateName": "c2fb27c7-5f67-49c4-aaf3-d82934234a69",
                "customDetails": {
                  "AlertManagementUri": "AlertManagementUri",
                  "Protocol": "Protocol",
                  "VendorOriginalId": "VendorOriginalId",
                  "Sensor": "DeviceId"
                },
                "description": "This alert leverages Defender for IoT to detect unauthorized changes to PLC ladder logic code indicating new functionality in the PLC, improper configuration of an application, or malicious activity on the network.",
                "displayName": "Unauthorized PLC changes (Microsoft Defender for IoT)",
                "enabled": true,
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let alertList = dynamic([\"Unpermitted Usage of Internal Indication (IIN)\", \"Modbus Address Range Violation\", \"Function Code Raised Unauthorized Exception\", \"Unauthorized Access to Siemens S7 Data Block\", \"Unauthorized Access to Wonderware Tag\", \"Unauthorized MMS Program Access\", \"GOOSE Message Type Settings\", \"Sampled Values Message Type Settings\", \"Foxboro I/A Unauthorized Operation\", \"New Activity Detected - CIP Class\", \"New Activity Detected - CIP Class Service\", \"New Activity Detected - CIP PCCC Command\", \"New Activity Detected - CIP Symbol\", \"New Activity Detected - EtherNet/IP I/O Connection\", \"New Activity Detected - EtherNet/IP Protocol Command\", \"New Activity Detected - GSM Message Code\", \"New Activity Detected - LonTalk Command Codes\", \"New Activity Detected - LonTalk Network Variable\", \"New Activity Detected - Ovation Data Request\", \"New Activity Detected - Read/Write Command (AMS Index Group)\", \"New Activity Detected - Read/Write Command (AMS Index Offset)\", \"New Activity Detected - Unauthorized DeltaV Message Type\", \"New Activity Detected - Unauthorized DeltaV ROC Operation\", \"New Activity Detected - Using AMS Protocol Command\", \"New Activity Detected - Using Siemens SICAM Command\", \"New Activity Detected - Using Suitelink Protocol command\", \"New Activity Detected - Using Suitelink Protocol sessions\", \"New Activity Detected - Using Yokogawa VNetIP Command\", \"Omron FINS Unauthorized Command\", \"Toshiba Computer Link Unauthorized Command\", \"Unauthorized ABB Totalflow File Operation\", \"Unauthorized ABB Totalflow Register Operation\", \"Unauthorized Access to Siemens S7 Plus Object\", \"Unauthorized BACNet Object Access\", \"Unauthorized BACNet Route\", \"Unauthorized Emerson ROC Operation\", \"Unauthorized GE SRTP File Access\", \"Unauthorized GE SRTP Protocol Command\", \"Unauthorized GE SRTP System Memory Operation\", \"Unauthorized Mitsubishi MELSEC Command\", \"Unauthorized MMS Service\", \"Unauthorized OPC UA Activity\", \"Unauthorized OPC UA Request/Response\", \"Unauthorized Profinet Frame Type\", \"Unauthorized SAIA S-Bus Command\", \"Unauthorized Siemens S7 Execution of Control Function\", \"Unauthorized Siemens S7 Execution of User Defined Function\", \"Unauthorized Siemens S7 Plus Block Access\", \"Unauthorized Siemens S7 Plus Operation\", \"Unauthorized SNMP Operation\", \"Unpermitted Modbus Schneider Electric Extension\", \"Unpermitted Usage of ASDU Types\", \"Unpermitted Usage of DNP3 Function Code\", \"Unpermitted Usage of Modbus Function Code\", \"Unauthorized Operation was detected by a User Defined Rule\", \"Unauthorized PLC Configuration Read\", \"Unauthorized PLC Programming\", \"Unauthorized PLC Configuration Write\", \"Unauthorized PLC Program Upload\"]);\nSecurityAlert\n| where ProviderName == \"IoTSecurity\"\n| where AlertName has_any (alertList) \n  or ExtendedProperties has_any (\"Illegal Beckhoff AMS Command\", \"Beckhoff AMS Command Failure\")\n| extend ExtendedProperties = parse_json(ExtendedProperties)\n| where tostring(ExtendedProperties.isNew) == \"True\"\n| extend DeviceId = tostring(ExtendedProperties.DeviceId), \n         SourceDeviceAddress = tostring(ExtendedProperties.SourceDeviceAddress), \n         DestDeviceAddress = tostring(ExtendedProperties.DestinationDeviceAddress), \n         RemediationSteps = tostring(parse_json(RemediationSteps)[0]), \n         Protocol = tostring(ExtendedProperties.Protocol), \n         AlertManagementUri = tostring(ExtendedProperties.AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri,\n  Techniques\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence"
                ],
                "techniques": [
                  "T0839"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/672d0101-ce9f-4fa1-8650-4b46d057273b')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "bb616d82-108f-47d3-9dec-9652ea0d3bf6",
                "description": "Search for user principal name (UPN) events. Look for accounts created and then deleted in under 24 hours. Attackers may create an account for their use, and then remove the account when no longer needed.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#short-lived-account",
                "displayName": "Account Created and Deleted in Short Timeframe",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "DeletedByIPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let queryfrequency = 1h;\nlet queryperiod = 1d;\nAuditLogs\n| where TimeGenerated > ago(queryfrequency)\n| where OperationName =~ \"Delete user\"\n//extend UserPrincipalName = tostring(TargetResources[0].userPrincipalName)\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type == \"User\"\n      | extend UserPrincipalName = extract(@'([a-f0-9]{32})?(.*)', 2, tostring(TargetResource.userPrincipalName))\n  )\n| extend DeletedByUser = tostring(InitiatedBy.user.userPrincipalName), DeletedByIPAddress = tostring(InitiatedBy.user.ipAddress)\n| extend DeletedByApp = tostring(InitiatedBy.app.displayName)\n| project Deletion_TimeGenerated = TimeGenerated, UserPrincipalName, DeletedByUser, DeletedByIPAddress, DeletedByApp, Deletion_AdditionalDetails = AdditionalDetails, Deletion_InitiatedBy = InitiatedBy, Deletion_TargetResources = TargetResources\n| join kind=inner (\n    AuditLogs\n    | where TimeGenerated > ago(queryperiod)\n    | where OperationName =~ \"Add user\"      \n    | mv-apply TargetResource = TargetResources on \n      (\n          where TargetResource.type == \"User\"\n          | extend UserPrincipalName = trim(@'\"',tostring(TargetResource.userPrincipalName))\n      )\n    | project-rename Creation_TimeGenerated = TimeGenerated\n) on UserPrincipalName\n| extend TimeDelta = Deletion_TimeGenerated - Creation_TimeGenerated\n| where  TimeDelta between (time(0s) .. queryperiod)\n| extend CreatedByUser = tostring(InitiatedBy.user.userPrincipalName), CreatedByIPAddress = tostring(InitiatedBy.user.ipAddress)\n| extend CreatedByApp = tostring(InitiatedBy.app.displayName)\n| project Creation_TimeGenerated, Deletion_TimeGenerated, TimeDelta, UserPrincipalName, DeletedByUser, DeletedByIPAddress, DeletedByApp, CreatedByUser, CreatedByIPAddress, CreatedByApp, Creation_AdditionalDetails = AdditionalDetails, Creation_InitiatedBy = InitiatedBy, Creation_TargetResources = TargetResources, Deletion_AdditionalDetails, Deletion_InitiatedBy, Deletion_TargetResources\n| extend timestamp = Deletion_TimeGenerated, Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])",
                "queryFrequency": "PT1H",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.0.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/e6f281d6-1dab-4164-9df7-20584b36c45a')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "(MDIoT) {{Description}}",
                  "alertDisplayNameFormat": "(MDIoT) {{AlertName}}",
                  "alertSeverityColumnName": "AlertSeverity",
                  "alertTacticsColumnName": "Tactics"
                },
                "alertRuleTemplateName": "7cad4b66-5e83-4756-8de4-f21315ab1e77",
                "customDetails": {
                  "AlertManagementUri": "AlertManagementUri",
                  "Protocol": "Protocol",
                  "VendorOriginalId": "VendorOriginalId",
                  "Sensor": "DeviceId"
                },
                "description": "This alert leverages Defender for IoT to detect unauthorized firmware updates that may indicate malicious activity on the network such as a cyber threat that attempts to manipulate PLC firmware to compromise PLC function.",
                "displayName": "Firmware Updates (Microsoft Defender for IoT)",
                "enabled": true,
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityAlert\n| where ProviderName == \"IoTSecurity\"\n| where AlertName has_any (\"Beckhoff Software Changed\", \"Firmware Version Changed\", \"Firmware Change\", \"Firmware Changed\", \"Firmware Update\")\n| extend ExtendedProperties = parse_json(ExtendedProperties)\n| where tostring(ExtendedProperties.isNew) == \"True\"\n| extend DeviceId = tostring(ExtendedProperties.DeviceId), \n         SourceDeviceAddress = tostring(ExtendedProperties.SourceDeviceAddress), \n         DestDeviceAddress = tostring(ExtendedProperties.DestinationDeviceAddress), \n         RemediationSteps = tostring(parse_json(RemediationSteps)[0]), \n         Protocol = tostring(ExtendedProperties.Protocol), \n         AlertManagementUri = tostring(ExtendedProperties.AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri,\n  Techniques\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence"
                ],
                "techniques": [
                  "T0857"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b375aa19-75b8-47c6-8ce0-6b9017515e31')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "69660e65-0e5c-4700-8b99-5caf59786606",
                "description": "This alert is triggered when a Microsoft Purview Insider Risk Management alert is recieved in Microsoft Sentinel via the Microsoft Purview Insider Risk Management Connector. The alert extracts usernames from security alerts to provide UserPrincipalName, Alert Name, Reporting Product Name, Status, Alert Link, Previous Alerts Links, Time Generated. There is an option for configuration of correlations against Microsoft Sentinel watchlists. For more information, see [Learn about insider risk management](https://docs.microsoft.com/microsoft-365/compliance/insider-risk-management)",
                "displayName": "Insider Risk_Microsoft Purview Insider Risk Management Alert Observed",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let AlertLinks = SecurityAlert\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize PreciousSecurityAlertLinks=make_set(AlertLink) by UPN;\nSecurityAlert\n| where ProductName == \"Microsoft 365 Insider Risk Management\"\n    | summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n    | mv-expand todynamic(Entities)\n    | where Entities[\"Type\"] =~ \"account\"\n    | extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n        Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n    | extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| join kind=inner (AlertLinks) on UPN\n| extend UserPrincipalName = UPN\n| extend PreviousAlertsLinks = strcat(PreciousSecurityAlertLinks)\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| project UserPrincipalName, AlertName, ProductName, Tactics, Status, AlertLink, PreviousAlertsLinks, TimeGenerated\n| sort by TimeGenerated desc\n| limit 25\n| extend AccountCustomEntity = UserPrincipalName\n",
                "queryFrequency": "PT6H",
                "queryPeriod": "PT6H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution"
                ],
                "techniques": [],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/8fffceed-6f16-42ac-aff2-3d2c02a9c732')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "45b903c5-6f56-4969-af10-ae62ac709718",
                "description": "Identifies when an RDP connection is new or rare related to any logon type by a given account today based on comparison with the previous 14 days.\nRDP connections are indicated by the EventID 4624 with LogonType = 10",
                "displayName": "Rare RDP Connections",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let starttime = 14d;\nlet endtime = 1d;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and LogonType == 10\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ConnectionCount = count()\nby Account = tolower(Account), Computer = toupper(Computer), IpAddress, AccountType, Activity, LogonTypeName, ProcessName\n// use left anti to exclude anything from the previous 14 days that is not rare\n),\n(WindowsEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and EventData has (\"10\")\n| extend LogonType = tostring(EventData.LogonType)\n| where  LogonType == 10\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend TargetUserSid = tostring(EventData.TargetUserSid)\n| extend AccountType=case(Account endswith \"$\" or TargetUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(TargetUserSid), \"\", \"User\")\n| extend Activity=\"4624 - An account was successfully logged on.\"\n| extend LogonTypeName=\"10 - RemoteInteractive\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), ConnectionCount = count()\nby Account = tolower(Account), Computer = toupper(Computer), IpAddress, AccountType, Activity, LogonTypeName, ProcessName\n))\n| join kind=leftanti (\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where EventID == 4624\n| summarize by Computer = toupper(Computer), IpAddress, Account = tolower(Account)\n),\n( WindowsEvent\n| where TimeGenerated between (ago(starttime) .. ago(endtime))\n| where EventID == 4624\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| summarize by Computer = toupper(Computer), IpAddress, Account = tolower(Account)\n))\n) on Account, Computer\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), ConnectionCount = sum(ConnectionCount)\nby Account, Computer, IpAddress, AccountType, Activity, LogonTypeName, ProcessName\n| extend timestamp = StartTime, AccountCustomEntity = Account, HostCustomEntity = Computer, IPCustomEntity = IpAddress",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "LateralMovement"
                ],
                "techniques": [
                  "T1021"
                ],
                "templateVersion": "1.2.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/67ca06ad-80b1-4bbe-b1bf-5865aa47b9a8')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "361dd1e3-1c11-491e-82a3-bb2e44ac36ba",
                "description": "Indicates when an anomalous number of VM creations or deployment activities occur in Azure via the AzureActivity log. This query generates the baseline pattern of cloud resource creation by an individual and generates an anomaly when any unusual spike is detected. These anomalies from unusual or privileged users could be an indication of a cloud infrastructure takedown by an adversary.",
                "displayName": "Suspicious number of resource creation or deployment activities",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      },
                      {
                        "columnName": "AadUserId",
                        "identifier": "AadUserId"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "CallerIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let szOperationNames = dynamic([\"microsoft.compute/virtualMachines/write\", \"microsoft.resources/deployments/write\"]);\nlet starttime = 7d;\nlet endtime = 1d;\nlet timeframe = 1d;\nlet TimeSeriesData =\nAzureActivity\n| where TimeGenerated between (startofday(ago(starttime)) .. startofday(now()))\n| where OperationNameValue in~ (szOperationNames)\n| project TimeGenerated, Caller \n| make-series Total = count() on TimeGenerated from startofday(ago(starttime)) to startofday(now()) step timeframe by Caller; \nTimeSeriesData\n| extend (anomalies, score, baseline) = series_decompose_anomalies(Total, 3, -1, 'linefit')\n| mv-expand Total to typeof(double), TimeGenerated to typeof(datetime), anomalies to typeof(double), score to typeof(double), baseline to typeof(long) \n| where TimeGenerated >= startofday(ago(endtime))\n| where anomalies > 0 and baseline > 0\n| project Caller, TimeGenerated, Total, baseline, anomalies, score\n| join (AzureActivity\n| where TimeGenerated > startofday(ago(endtime)) \n| where OperationNameValue in~ (szOperationNames)\n| summarize make_set(OperationNameValue,100), make_set(_ResourceId,100), make_set(CallerIpAddress,100) by bin(TimeGenerated, timeframe), Caller\n) on TimeGenerated, Caller\n| mv-expand CallerIpAddress=set_CallerIpAddress\n| project-away Caller1\n| extend Name = iif(Caller has '@',tostring(split(Caller,'@',0)[0]),\"\")\n| extend UPNSuffix = iif(Caller has '@',tostring(split(Caller,'@',1)[0]),\"\")\n| extend AadUserId = iif(Caller !has '@',Caller,\"\")",
                "queryFrequency": "P1D",
                "queryPeriod": "P7D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [
                  "T1496"
                ],
                "templateVersion": "2.0.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/c8f24e19-431a-415b-b06d-b23c98cc7fdb')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "0dd2a343-4bf9-4c93-a547-adf3658ddaec",
                "description": "This detection highlights executables deployed to hosts via either the Default Domain or Default Domain Controller Policies. These policies apply to all hosts or Domain Controllers and best practice is that these policies should not be used for deployment of files.\n  A threat actor may use these policies to deploy files or scripts to all hosts in a domain.\n  This query uses the ASIM parsers and will need them deployed before usage - https://docs.microsoft.com/azure/sentinel/normalization",
                "displayName": "New EXE deployed via Default Domain or Default Domain Controller Policies (ASIM Version)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "DvcHostname",
                        "identifier": "HostName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let known_processes = (\n  imProcess\n  // Change these values if adjusting Query Frequency or Query Period\n  | where TimeGenerated between(ago(14d)..ago(1d))\n  | where Process has_any (\"Policies\\\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\", \"Policies\\\\{31B2F340-016D-11D2-945F-00C04FB984F9}\")\n  | summarize by Process);\n  imProcess\n  // Change these values if adjusting Query Frequency or Query Period\n  | where TimeGenerated > ago(1d)\n  | where Process has_any (\"Policies\\\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\", \"Policies\\\\{31B2F340-016D-11D2-945F-00C04FB984F9}\")\n  | where Process !in (known_processes)\n  | summarize FirstSeen=min(TimeGenerated), LastSeen=max(TimeGenerated) by Process, CommandLine, DvcHostname",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution",
                  "LateralMovement"
                ],
                "techniques": [
                  "T1072",
                  "T1570"
                ],
                "templateVersion": "1.0.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b0b156e1-14a4-464c-9b0c-51529edff3de')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "15386bba-dc70-463f-a09f-d392e7731c63",
                "description": "This alert evaluates Azure Active Directory Sign in risk via Machine Learning correlations in the basket operator. The basket threshold is adjustable, and the default is set to .01. There is an optional configuration to configure the percentage rates. The correlations are designed to leverage machine learning to identify patterns of risky user application access. There is an option for configuration of correlations against Microsoft Sentinel watchlists. For more information, see [Tutorial: Use risk detections for user sign-ins to trigger Azure AD Multi-Factor Authentication or password changes](https://docs.microsoft.com/azure/active-directory/authentication/tutorial-risk-based-sspr-mfa)",
                "displayName": "Insider Risk_Risky User Access By Application",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SigninLogs\n| where RiskState == \"atRisk\"\n| project UserPrincipalName, Location, AppDisplayName, RiskState\n| evaluate basket(0.01) // Adjust & Tune Thresholds within Organzational Requirements\n// | where Percent > 50 // Adjust & Tune Thresholds within Organzational Requirements\n| where UserPrincipalName <> \"\"\n| where AppDisplayName <> \"\"\n| project Percent, UserPrincipalName, Location, AppDisplayName, RiskState\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UserPrincipalName == $right.SearchKey\n| sort by Percent desc\n| limit 25\n| extend AccountCustomEntity = UserPrincipalName\n",
                "queryFrequency": "PT6H",
                "queryPeriod": "PT6H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution"
                ],
                "techniques": [],
                "templateVersion": "1.1.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/78ce0ac9-c15d-44b6-9bfc-eda73af4319b')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "4ce177b3-56b1-4f0e-b83e-27eed4cb0b16",
                "description": "As seen in attacks such as SolarWinds attackers can look to subvert a build process by controlling build servers. Azure DevOps uses agent pools to execute pipeline tasks. \nAn attacker could insert compromised agents that they control into the pools in order to execute malicious code. This query looks for users adding agents to pools they have \nnot added agents to before, or adding agents to a pool of an OS that has not been added to that pool before. This detection has potential for false positives so has a \nconfigurable allow list to allow for certain users to be excluded from the logic.",
                "displayName": "New Agent Added to Pool by New User or Added to a New OS Type.",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let lookback = 14d;\nlet timeframe = 1d;\n// exclude allowed users from query such as the ADO service\nlet allowed_users = dynamic([\"Azure DevOps Service\"]);\nunion\n// Look for agents being added to a pool of a OS type not seen with that pool before\n(AzureDevOpsAuditing\n| where TimeGenerated > ago(lookback) and TimeGenerated < ago(timeframe)\n| where OperationName =~ \"Library.AgentAdded\"\n| where ActorUPN !in (allowed_users)\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| extend OsDescription = tostring(Data.OsDescription)\n| where isnotempty(OsDescription)\n| extend OsDescription = tostring(split(OsDescription, \"#\", 0)[0])\n| project AgentPoolName, OsDescription\n| join kind=rightanti (AzureDevOpsAuditing\n| where TimeGenerated > ago(timeframe)\n| where OperationName == \"Library.AgentAdded\"\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| extend OsDescription = tostring(Data.OsDescription)\n| where isnotempty(OsDescription)\n| extend OsDescription = tostring(split(OsDescription, \"#\", 0)[0])) on AgentPoolName, OsDescription),\n// Look for users addeing agents to a pool that they have not added agents to before.\n(AzureDevOpsAuditing\n| where TimeGenerated > ago(lookback) and TimeGenerated < ago(timeframe)\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n| where ActorUPN !in (allowed_users)\n| project AgentPoolName, ActorUPN\n| join kind=rightanti (AzureDevOpsAuditing\n| where TimeGenerated > ago(timeframe)\n| where OperationName == \"Library.AgentAdded\"\n| where ActorUPN !in (allowed_users)\n| extend AgentPoolName = tostring(Data.AgentPoolName)\n) on AgentPoolName, ActorUPN)\n| extend AgentName = tostring(Data.AgentName)\n| extend OsDescription = tostring(Data.OsDescription)\n| extend SystemDetails = Data.SystemCapabilities\n| project-reorder TimeGenerated, OperationName, ScopeDisplayName, AgentPoolName, AgentName, ActorUPN, IpAddress, UserAgent, OsDescription, SystemDetails, Data\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution"
                ],
                "techniques": [
                  "T1053"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/5de3ca9c-cd9d-4329-b63b-65542de31a39')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "45076281-35ae-45e0-b443-c32aa0baf965",
                "description": "Identifies the host and account that executed AdFind by hash and filename in addition to common and unique flags that are used by many threat actors in discovery.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)",
                "displayName": "Probable AdFind Recon Tool Usage (Normalized Process Events)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "HostName"
                      }
                    ]
                  },
                  {
                    "entityType": "Process",
                    "fieldMappings": [
                      {
                        "columnName": "ProcessCustomEntity",
                        "identifier": "ProcessId"
                      },
                      {
                        "columnName": "CommandLineCustomEntity",
                        "identifier": "CommandLine"
                      }
                    ]
                  },
                  {
                    "entityType": "FileHash",
                    "fieldMappings": [
                      {
                        "columnName": "AlgorithmCustomEntity",
                        "identifier": "Algorithm"
                      },
                      {
                        "columnName": "FileHashCustomEntity",
                        "identifier": "Value"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let args = dynamic([\"objectcategory\",\"domainlist\",\"dcmodes\",\"adinfo\",\"trustdmp\",\"computers_pwdnotreqd\",\"Domain Admins\", \"objectcategory=person\", \"objectcategory=computer\", \"objectcategory=*\",\"dclist\"]);\nlet parentProcesses = dynamic([\"pwsh.exe\",\"powershell.exe\",\"cmd.exe\"]);\nimProcessCreate\n//looks for execution from a shell\n| where ActingProcessName has_any (parentProcesses)\n| extend ActingProcessFileName = tostring(split(ActingProcessName, '\\\\')[-1])\n| where ActingProcessFileName in~ (parentProcesses)\n// main filter\n| where Process hassuffix \"AdFind.exe\" or TargetProcessSHA256 == \"c92c158d7c37fea795114fa6491fe5f145ad2f8c08776b18ae79db811e8e36a3\"\n    // AdFind common Flags to check for from various threat actor TTPs\n    or CommandLine has_any (args)\n| extend AccountCustomEntity = User, HostCustomEntity = Dvc, ProcessCustomEntity = ActingProcessName, CommandLineCustomEntity = CommandLine, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = TargetProcessSHA256",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Discovery"
                ],
                "techniques": [
                  "T1018"
                ],
                "templateVersion": "1.1.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/9cd1632b-f8fc-4573-ab21-466317a19876')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "The host at address {{SrcIpAddr}} sent an HTTP request to the URL {{Url}} with the HTTP user agent header {{HttpUserAgent}}. This user agent is known to be used by a hacking tool and indicates suspicious activity on the host.",
                  "alertDisplayNameFormat": "Host {{SrcIpAddr}} is potentially running a hacking tool"
                },
                "alertRuleTemplateName": "3f0c20d5-6228-48ef-92f3-9ff7822c1954",
                "customDetails": {
                  "UserAgent": "HttpUserAgent"
                },
                "description": "This rule identifies a web request with a user agent header known to belong to a hacking tool. This indicates a hacking tool is used on the host.<br>You can add custom hacking tool indicating User-Agent headers using a watchlist, for more information refer to the [UnusualUserAgents Watchlist](https://aka.ms/ASimUnusualUserAgentsWatchlist).<br><br>\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)",
                "displayName": "A host is potentially running a hacking tool (ASIM Web Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Url",
                        "identifier": "Url"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "SrcUsername",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threatCategory=\"Hacking Tool\";\nlet knownUserAgentsIndicators = materialize(externaldata(UserAgent:string, Category:string)\n    [ @\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/UnusualUserAgents.csv\"] \n        with(format=\"csv\", ignoreFirstRecord=True));\nlet knownUserAgents=toscalar(knownUserAgentsIndicators | where Category==threatCategory | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet customUserAgents=toscalar(_GetWatchlist(\"UnusualUserAgents\") | where SearchKey==threatCategory | extend UserAgent=column_ifexists(\"UserAgent\",\"\") | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet fullUAList = array_concat(knownUserAgents,customUserAgents);\n_Im_WebSession(httpuseragent_has_any=fullUAList)\n| project SrcIpAddr, Url, TimeGenerated,HttpUserAgent, SrcUsername",
                "queryFrequency": "PT15M",
                "queryPeriod": "PT15M",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CommandAndControl"
                ],
                "techniques": [],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/5f7b1037-32b5-4efc-b1ee-840a9d976fa8')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "1ff56009-db01-4615-8211-d4fda21da02d",
                "description": "Identifies when the Microsoft Graph RoleManagement.ReadWrite.Directory (Delegated or Application) permission is granted to a service principal.\nThis permission allows an application to read and manage the role-based access control (RBAC) settings for your company's directory.\nAn adversary could use this permission to add an Azure AD object to an Admin directory role and escalate privileges.\nRef : https://docs.microsoft.com/graph/permissions-reference#role-management-permissions\nRef : https://docs.microsoft.com/graph/api/directoryrole-post-members?view=graph-rest-1.0&tabs=http",
                "displayName": "Azure AD Role Management Permission Grant",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AppDisplayName",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where Category =~ \"ApplicationManagement\" and LoggedByService =~ \"Core Directory\" and OperationName in~ (\"Add delegated permission grant\", \"Add app role assignment to service principal\")\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n      | extend props = TargetResource.modifiedProperties\n  )\n| mv-apply Property = props on \n  (\n      where Property.displayName in~ (\"AppRole.Value\",\"DelegatedPermissionGrant.Scope\")\n      | extend DisplayName = tostring(Property.displayName), PermissionGrant = trim('\"',tostring(Property.newValue))\n  )\n| where PermissionGrant has \"RoleManagement.ReadWrite.Directory\"\n| mv-apply Property = props on \n  (\n      where Property.displayName =~ \"ServicePrincipal.DisplayName\"\n      | extend AppDisplayName = trim('\"',tostring(Property.newValue))\n  )\n| mv-apply Property = props on \n  (\n      where Property.displayName =~ \"ServicePrincipal.ObjectID\"\n      | extend AppServicePrincipalId = trim('\"',tostring(Property.newValue))\n  )\n| extend \n    Initiator = iif(isnotempty(InitiatedBy.app), tostring(InitiatedBy.app.displayName), tostring(InitiatedBy.user.userPrincipalName)),\n    InitiatorId = iif(isnotempty(InitiatedBy.app), tostring(InitiatedBy.app.servicePrincipalId), tostring(InitiatedBy.user.id))\n| project TimeGenerated, OperationName, Result, PermissionGrant, AppDisplayName, AppServicePrincipalId, Initiator, InitiatorId, InitiatedBy, TargetResources, AdditionalDetails, CorrelationId\n| extend Name = tostring(split(Initiator,'@',0)[0]), UPNSuffix = tostring(split(Initiator,'@',1)[0])",
                "queryFrequency": "PT2H",
                "queryPeriod": "PT2H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence",
                  "Impact"
                ],
                "techniques": [
                  "T1098",
                  "T1078"
                ],
                "templateVersion": "1.0.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/7692e8af-163a-4ab4-8730-17746761b77d')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "32ffb19e-8ed8-40ed-87a0-1adb4746b7c4",
                "description": "This query detects the creation of credential dumping tools files. Several credential dumping tools export files with hardcoded file names.\nRef: https://jpcertcc.github.io/ToolAnalysisResultSheet/",
                "displayName": "Credential Dumping Tools - File Artifacts",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "File",
                    "fieldMappings": [
                      {
                        "columnName": "TargetFilename",
                        "identifier": "Name"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostName",
                        "identifier": "HostName"
                      },
                      {
                        "columnName": "DnsDomain",
                        "identifier": "DnsDomain"
                      }
                    ]
                  },
                  {
                    "entityType": "Process",
                    "fieldMappings": [
                      {
                        "columnName": "Image",
                        "identifier": "CommandLine"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "// Enter a reference list of malicious file artifacts\nlet MaliciousFileArtifacts = dynamic ([\"lsass.dmp\",\"test.pwd\",\"lsremora.dll\",\"lsremora64.dll\",\"fgexec.exe\",\"pwdump\",\"kirbi\",\"wce_ccache\",\"wce_krbtkts\",\"wceaux.dll\",\"PwHashes\",\"SAM.out\",\"SECURITY.out\",\"SYSTEM.out\",\"NTDS.out\" \"DumpExt.dll\",\"DumpSvc.exe\",\"cachedump64.exe\",\"cachedump.exe\",\"pstgdump.exe\",\"servpw64.exe\",\"servpw.exe\",\"pwdump.exe\",\"fgdump-log\"]);\nEvent\n| where EventLog == \"Microsoft-Windows-Sysmon/Operational\" and EventID==11\n| parse EventData with * 'TargetFilename\">' TargetFilename \"<\" *\n| where TargetFilename has_any (MaliciousFileArtifacts)\n| parse EventData with * 'ProcessGuid\">' ProcessGuid \"<\" * 'Image\">' Image \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, Image, ProcessGuid, TargetFilename\n| extend HostName = split(Computer, '.', 0)[0], DnsDomain = strcat_array(array_slice(split(Computer, '.'), 1, -1), '.')",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1003"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/12897552-ca20-48d6-9892-2b615c2afc42')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "ac891683-53c3-4f86-86b4-c361708e2b2b",
                "description": "This Alert detects whenever a PAT is used in ways that PATs are not normally used. May require an allow list and baselining.\nReference - https://docs.microsoft.com/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&tabs=preview-page\nUse this query for baselining:\nAzureDevOpsAuditing\n| distinct OperationName",
                "displayName": "Azure DevOps Personal Access Token (PAT) misuse",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "// Allowlisted UPNs should likely stay empty\nlet AllowlistedUpns = datatable(UPN:string)['foo@bar.com', 'test@foo.com'];\n// Operation Name parts that will alert\nlet HasAnyBlocklist = datatable(OperationNamePart:string)['Security.','Project.','AuditLog.','Extension.'];\n// Distinct Operation Names that will flag\nlet HasExactBlocklist = datatable(OperationName:string)['Group.UpdateGroupMembership.Add','Library.ServiceConnectionExecuted','Pipelines.PipelineModified',\n'Release.ReleasePipelineModified', 'Git.RefUpdatePoliciesBypassed'];\nAzureDevOpsAuditing\n| where AuthenticationMechanism startswith \"PAT\" and (OperationName has_any (HasAnyBlocklist) or OperationName in (HasExactBlocklist))\n  and ActorUPN !in (AllowlistedUpns)\n| project TimeGenerated, AuthenticationMechanism, ProjectName, ActorUPN, ActorDisplayName, IpAddress, UserAgent, OperationName, Details, Data\n| extend timestamp = TimeGenerated, AccountCustomEntity = ActorUPN, IPCustomEntity = IpAddress",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution",
                  "Impact"
                ],
                "techniques": [
                  "T1496",
                  "T1559"
                ],
                "templateVersion": "1.0.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/462cdb73-b7b6-40e5-8b5d-bdc0096e019e')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "d99cf5c3-d660-436c-895b-8a8f8448da23",
                "description": "Identifies accurances where a user has rejected an MFA prompt. This could be an indicator that a threat actor has compromised the username and password of this user account and is using it to try and log into the account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-user-accounts#monitoring-for-failed-unusual-sign-ins",
                "displayName": "MFA Rejected by User",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      },
                      {
                        "columnName": "UserId",
                        "identifier": "AadUserId"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SigninLogs\n| where ResultType == 500121\n| extend additionalDetails_ = tostring(Status.additionalDetails)\n| where additionalDetails_ =~ \"MFA denied; user declined the authentication\"\n| summarize StartTime = min(TimeGenerated), EndTIme = max(TimeGenerated) by UserPrincipalName, UserId, AADTenantId, IPAddress\n| extend Name = tostring(split(UserPrincipalName,'@',0)[0]), UPNSuffix = tostring(split(UserPrincipalName,'@',1)[0])",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.0.5",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/3cddafa9-35a3-4837-b3bd-afe22a3d6fb3')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "6b652b4f-9810-4eec-9027-7aa88ce4db23",
                "description": "The query below identifies dllhost.exe using WMIC to discover additional hosts and associated domains in the environment.",
                "displayName": "Dev-0270 WMIC  Discovery",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "(union isfuzzy=true\n(SecurityEvent\n| where EventID==4688\n| where CommandLine has \"wmic computersystem get domain\" and ParentProcessName has \"dllhost.exe\"\n| project TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account, AccountDomain, ProcessName, ProcessNameFullPath = NewProcessName, EventID, Activity, CommandLine, EventSourceName, Type\n),\n(DeviceProcessEvents \n| where ProcessCommandLine has \"wmic computersystem get domain\" and InitiatingProcessFileName =~ \"dllhost.exe\" and InitiatingProcessCommandLine has \"dllhost.exe\"\n| extend timestamp = TimeGenerated, AccountCustomEntity =  InitiatingProcessAccountName, HostCustomEntity = DeviceName\n)\n)",
                "queryFrequency": "PT6H",
                "queryPeriod": "PT6H",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Discovery"
                ],
                "techniques": [
                  "T1482"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/d2483838-30a4-417c-8d23-10f903848591')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "5170c3c4-b8c9-485c-910d-a21d965ee181",
                "description": "Identifies evidence of password spray activity against Connect Health for AD FS sign-in events by looking for failures from multiple accounts from the same IP address within a time window.\nReference: https://adfshelp.microsoft.com/References/ConnectHealthErrorCodeReference",
                "displayName": "Password spray attack against ADFSSignInLogs",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let queryfrequency = 30m;\nlet accountthreshold = 10;\nlet successCodes = dynamic([0, 50144]);\nADFSSignInLogs\n| extend IngestionTime = ingestion_time()\n| where IngestionTime > ago(queryfrequency)\n| where not(todynamic(AuthenticationDetails)[0].authenticationMethod == \"Integrated Windows Authentication\")\n| summarize\n    DistinctFailureCount = dcountif(UserPrincipalName, ResultType !in (successCodes)),\n    DistinctSuccessCount = dcountif(UserPrincipalName, ResultType in (successCodes)),\n    SuccessAccounts = make_set_if(UserPrincipalName, ResultType in (successCodes), 250),\n    arg_min(TimeGenerated, *)\n    by IPAddress\n| where DistinctFailureCount > DistinctSuccessCount and DistinctFailureCount >= accountthreshold\n//| extend SuccessAccounts = iff(array_length(SuccessAccounts) != 0, SuccessAccounts, dynamic([\"null\"]))\n//| mv-expand SuccessAccounts\n| project TimeGenerated, Category, OperationName, IPAddress, DistinctFailureCount, DistinctSuccessCount, SuccessAccounts, AuthenticationRequirement, ConditionalAccessStatus, IsInteractive, UserAgent, NetworkLocationDetails, DeviceDetail, TokenIssuerType, TokenIssuerName, ResourceIdentity\n",
                "queryFrequency": "PT30M",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1110"
                ],
                "templateVersion": "1.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/1b522e9d-ab3e-4cbe-9e2b-975d826b4bd2')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "c61b167a-59ae-42af-bc98-36c78c5acb5c",
                "description": "This alert is designed to monitor recommended data tables aligned to the Maturity Model for Event Log Management (M-21-31) standard. The alert triggers when a recommended data table hasn't been observed in over 48 hours.",
                "displayName": "M2131_RecommendedDatatableUnhealthy",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "CloudApplication",
                    "fieldMappings": [
                      {
                        "columnName": "DataTable",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let M2131Mapping = datatable(DataTable:string, MaturityLevel:string)\n[\n\"SigninLogs\",\t\"Event Logging (EL0)\",\n\"AADManagedIdentitySignInLogs\", \"Event Logging (EL0)\",\n\"AADServicePrincipalSignInLogs\",\t\"Event Logging (EL0)\",\n\"StorageBlobLogs\",\t\"Event Logging (EL0)\",\n\"StorageFileLogs\",\t\"Event Logging (EL0)\",\n\"AzureMetrics\",\t\"Event Logging (EL0)\",\n\"AuditLogs\",\t\"Event Logging (EL0)\",\n\"IdentityInfo\",\t\"Event Logging (EL0)\",\n\"CommonSecurityLog\",\t\"Event Logging (EL0)\",\n\"ThreatIntelligenceIndicator\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkInfo\",\t\"Event Logging (EL0)\",\n\"DnsEvents\",\t\"Event Logging (EL0)\",\n\"DeviceNetworkEvents\",\t\"Event Logging (EL0)\",\n\"AzureDiagnostics\",\t\"Event Logging (EL0)\",\n\"Usage\",\t\"Event Logging (EL0)\",\n\"SecurityIncident\",\t\"Event Logging (EL0)\",\n\"SecurityAlert\",\t\"Event Logging (EL0)\",\n\"AzureActivity\",\t\"Event Logging (EL0)\",\n\"Heartbeat\",\t\"Event Logging (EL0)\",\n\"OfficeActivity\",\t\"Event Logging (EL0)\",\n\"SecurityEvent\",\t\"Event Logging (EL0)\",\n\"Syslog\",\t\"Event Logging (EL0)\",\n\"AWSCloudTrail\",\t\"Event Logging (EL0)\",\n\"GWorkspaceActivityReports\",\t\"Event Logging (EL0)\",\n\"AWSGuardDuty\",\t\"Event Logging (EL0)\",\n\"AWSVPCFlow\",\t\"Event Logging (EL0)\",\n\"Perf\",\t\"Basic Event Logging (EL1)\",\n\"SentinelHealth\",\t\"Basic Event Logging (EL1)\",\n\"DeviceLogonEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceNetworkEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceFileEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceRegistryEvents\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"VMConnection\",\t\"Basic Event Logging (EL1)\",\n\"EmailEvents\",\t\"Basic Event Logging (EL1)\",\n\"ThreatIntelligenceIndicator\",\t\"Basic Event Logging (EL1)\",\n\"SecurityRecommendation\",\t\"Basic Event Logging (EL1)\",\n\"DeviceProcessEvents\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationData\",\t\"Basic Event Logging (EL1)\",\n\"ConfigurationChange\",\t\"Basic Event Logging (EL1)\",\n\"GatewayDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"TunnelDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"IKEDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"RouteDiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"PS2DiagnosticLog\",\t\"Basic Event Logging (EL1)\",\n\"Event\",\t\"Basic Event Logging (EL1)\",\n\"SqlAtpStatus\",\t\"Basic Event Logging (EL1)\",\n\"ConstainerInstanceLog_CL\",\t\"Basic Event Logging (EL1)\",\n\"ContainerEvent_CL\",\t\"Basic Event Logging (EL1)\",\n\"InsightsMetrics\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailUrlInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"EmailAttachmentInfo\",\t\"Intermediate Event Logging (EL2)\",\n\"InformationProtectionLogs_CL\",\t\"Intermediate Event Logging (EL2)\",\n\"CloudAppEvents\",\t\"Intermediate Event Logging (EL2)\",\n\"ContainerInventory\",\t\"Intermediate Event Logging (EL2)\",\n\"Update\",\t\"Advanced Event Logging (EL3)\",\n\"BehaviorAnalytics\",\t\"Advanced Event Logging (EL3)\",\n\"Anomalies\",\t\"Advanced Event Logging (EL3)\",\n\"SecurityRegulatoryCompliance\",\t\"Advanced Event Logging (EL3)\"\n];\nlet LastLogTime = Usage\n| summarize LastLog_Time = arg_max(TimeGenerated, *) by DataType;\nUsage\n| summarize last_log = datetime_diff(\"day\",now(), max(TimeGenerated)) by DataType\n| where last_log > 0\n| join kind=inner (LastLogTime) on DataType\n| project DataTable = DataType, ['Last Log Received'] = last_log, LastLog_Time\n| where ['Last Log Received'] > 2\n| join kind=inner (M2131Mapping) on DataTable\n| project-away DataTable1\n| order by ['Last Log Received'] desc\n| extend CloudApplication = DataTable\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Discovery"
                ],
                "techniques": [
                  "T1082"
                ],
                "templateVersion": "1.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/8ea63a42-60ae-4353-adfe-68fdec901f9b')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "050b9b3d-53d0-4364-a3da-1b678b8211ec",
                "description": "Identifies when a new privileged role is assigned to a user.  Any account eligible for a role is now being given privileged access. If the assignment is unexpected or into a role that isn't the responsibility of the account holder, investigate.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1",
                "displayName": "User Assigned Privileged Role",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "TargetName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "TargetUPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatorName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "InitiatorUPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\")\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend Target = tostring(TargetResource.userPrincipalName),\n               props = TargetResource.modifiedProperties\n  )\n| mv-apply Property = props on \n  (\n      where Property.displayName =~ \"Role.DisplayName\"\n      | extend RoleName = trim('\"',tostring(Property.newValue))\n  )\n| where RoleName contains \"Admin\"\n| extend InitiatingApp = tostring(InitiatedBy.app.displayName)\n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(InitiatedBy.user.userPrincipalName))\n// Uncomment below to not alert for PIM activations\n//| where Initiator != \"MS-PIM\"\n| summarize by bin(TimeGenerated, 1h), OperationName,  RoleName, Target, Initiator, Result\n| extend TargetName = tostring(split(Target,'@',0)[0]), TargetUPNSuffix = tostring(split(Target,'@',1)[0]), InitiatorName = tostring(split(Initiator,'@',0)[0]), InitiatorUPNSuffix = tostring(split(Initiator,'@',1)[0])",
                "queryFrequency": "PT2H",
                "queryPeriod": "PT2H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.0.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/e3dc0ad0-9331-4187-96f2-05419110d635')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "871ba14c-88ef-48aa-ad38-810f26760ca3",
                "description": "Identifies when multiple (more than one) users mailboxes are configured to forward to the same destination. \nThis could be an attacker-controlled destination mailbox configured to collect mail from multiple compromised user accounts.",
                "displayName": "Multiple users email forwarded to same destination",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let queryfrequency = 1d;\nlet queryperiod = 7d;\nOfficeActivity\n| where TimeGenerated > ago(queryperiod)\n| where OfficeWorkload =~ \"Exchange\"\n//| where Operation in (\"Set-Mailbox\", \"New-InboxRule\", \"Set-InboxRule\")\n| where Parameters has_any (\"ForwardTo\", \"RedirectTo\", \"ForwardingSmtpAddress\")\n| mv-apply DynamicParameters = todynamic(Parameters) on (summarize ParsedParameters = make_bag(pack(tostring(DynamicParameters.Name), DynamicParameters.Value)))\n| evaluate bag_unpack(ParsedParameters, columnsConflict='replace_source')\n| extend DestinationMailAddress = tolower(case(\n    isnotempty(column_ifexists(\"ForwardTo\", \"\")), column_ifexists(\"ForwardTo\", \"\"),\n    isnotempty(column_ifexists(\"RedirectTo\", \"\")), column_ifexists(\"RedirectTo\", \"\"),\n    isnotempty(column_ifexists(\"ForwardingSmtpAddress\", \"\")), trim_start(@\"smtp:\", column_ifexists(\"ForwardingSmtpAddress\", \"\")),\n    \"\"))\n| where isnotempty(DestinationMailAddress)\n| mv-expand split(DestinationMailAddress, \";\")\n| extend ClientIPValues = extract_all(@'\\[?(::ffff:)?(?P<IPAddress>(\\d+\\.\\d+\\.\\d+\\.\\d+)|[^\\]]+)\\]?([-:](?P<Port>\\d+))?', dynamic([\"IPAddress\", \"Port\"]), ClientIP)[0]\n| extend ClientIP = tostring(ClientIPValues[0]), Port = tostring(ClientIPValues[1])\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), DistinctUserCount = dcount(UserId), UserId = make_set(UserId, 250), Ports = make_set(Port, 250), EventCount = count() by tostring(DestinationMailAddress), ClientIP\n| where DistinctUserCount > 1 and EndTime > ago(queryfrequency)\n| mv-expand UserId to typeof(string)\n| extend timestamp = StartTime, AccountCustomEntity = UserId, IPCustomEntity = ClientIP\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P7D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Collection",
                  "Exfiltration"
                ],
                "techniques": [],
                "templateVersion": "2.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/c6307cad-e97f-420b-93d0-eb0d965ee0af')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "1bf6e165-5e32-420e-ab4f-0da8558a8be2",
                "description": "The query looks for source code files being modified immediately after a build process is started. The purpose of this is to look for malicious code injection during the build process. This query uses Microsoft Defender for Endpoint telemetry.\nMore details: https://techcommunity.microsoft.com/t5/azure-sentinel/monitoring-the-software-supply-chain-with-azure-sentinel/ba-p/2176463",
                "displayName": "Potential Build Process Compromise - MDE",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostName",
                        "identifier": "HostName"
                      },
                      {
                        "columnName": "DnsDomain",
                        "identifier": "DnsDomain"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "// How far back to look for events from\nlet timeframe = 1d;\n// How close together build events and file modifications should occur to alert (make this smaller to reduce FPs)\nlet time_window = 5m;\n// Edit this to include build processes used\nlet build_processes = dynamic([\"MSBuild.exe\", \"dotnet.exe\", \"VBCSCompiler.exe\"]);\n// Include any processes that you want to allow to edit files during/around the build process\nlet allow_list = dynamic([]);\nDeviceProcessEvents\n| where TimeGenerated > ago(timeframe)\n// Look for build process starts\n| where FileName has_any (build_processes)\n| summarize by BuildParentProcess=InitiatingProcessFileName, BuildProcess=FileName, BuildAccount = AccountName, DeviceName, BuildCommand=ProcessCommandLine, timekey= bin(TimeGenerated, time_window), BuildProcessTime=TimeGenerated\n| join kind=inner(\nDeviceFileEvents\n| where TimeGenerated > ago(timeframe)\n| where InitiatingProcessFileName !in (allow_list)\n| where ActionType == \"FileCreated\"  or ActionType == \"FileModified\"\n// Look for code files, edit this to include file extensions used in build.\n| where FileName endswith \".cs\" or FileName endswith \".cpp\"\n| summarize by FileEditParentProcess=InitiatingProcessParentFileName, FileEditAccount = InitiatingProcessAccountName, DeviceName, FileEdited=FileName, FileEditProcess=InitiatingProcessFileName, timekey= bin(TimeGenerated, time_window), FileEditTime=TimeGenerated)\n// join where build processes and file modifications seen at same time on same host\non timekey, DeviceName\n// Limit to only where the file edit happens after the build process starts\n| where BuildProcessTime <= FileEditTime\n| summarize make_set(FileEdited), make_set(FileEditProcess), make_set(FileEditAccount) by timekey, DeviceName, BuildParentProcess, BuildProcess\n| extend HostName = iff(DeviceName has '.', substring(DeviceName,0,indexof(DeviceName,'.')),DeviceName)\n| extend DnsDomain = iff(DeviceName has '.', substring(DeviceName,indexof(DeviceName,'.')+1),\"\")",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence"
                ],
                "techniques": [
                  "T1554"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/10d15d81-16db-4e89-b36d-b2f783229812')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "7d7e20f8-3384-4b71-811c-f5e950e8306c",
                "description": "Identifies when a user is rejected for a privileged role elevation via PIM. Monitor rejections for indicators of attacker compromise of the requesting account.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-identity-management",
                "displayName": "PIM Elevation Request Rejected",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatingName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "InitiatingUPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "UserName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UserUPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatingIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where ActivityDisplayName =~'Add member to role completed (PIM activation)'\n| where Result =~ \"failure\"\n| mv-apply ResourceItem = TargetResources on \n  (\n      where ResourceItem.type =~ \"Role\"\n      | extend Role = trim(@'\"',tostring(ResourceItem.displayName))\n  )\n| mv-apply ResourceItem = TargetResources on \n  (\n      where ResourceItem.type =~ \"User\"\n      | extend User = trim(@'\"',tostring(ResourceItem.userPrincipalName))\n  )\n| project-reorder TimeGenerated, User, Role, OperationName, Result, ResultDescription\n| where isnotempty(InitiatedBy.user)\n| extend InitiatingUser = tostring(InitiatedBy.user.userPrincipalName), InitiatingIpAddress = tostring(InitiatedBy.user.ipAddress)\n| extend InitiatingName = tostring(split(InitiatingUser,'@',0)[0]), InitiatingUPNSuffix = tostring(split(InitiatingUser,'@',1)[0])\n| extend UserName = tostring(split(User,'@',0)[0]), UserUPNSuffix = tostring(split(User,'@',1)[0])",
                "queryFrequency": "PT2H",
                "queryPeriod": "PT2H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.0.5",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/c52383b7-2938-48af-94db-f782d2f1c7e4')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "b9e3b9f8-a406-4151-9891-e5ff1ddd8c1d",
                "description": "This query identifies the additional files uploaded by the same IP address which triggered a malware alert for malicious content upload on Azure Blob or File Storage Container.",
                "displayName": "Linked Malicious Storage Artifacts",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "AttackerIP",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "FileHash",
                    "fieldMappings": [
                      {
                        "columnName": "HashAlgorithm",
                        "identifier": "Algorithm"
                      },
                      {
                        "columnName": "LinkedMaliciousFileHash",
                        "identifier": "Value"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "//Collect the alert events\nlet alertData = SecurityAlert\n| where DisplayName has \"Potential malware uploaded to\"\n| extend Entities = parse_json(Entities)\n| mv-expand Entities;\n//Parse the IP address data\nlet ipData = alertData\n| where Entities['Type'] =~ \"ip\"\n| extend AttackerIP = tostring(Entities['Address']), AttackerCountry = tostring(Entities['Location']['CountryName']);\n//Parse the file data\nlet FileData = alertData\n| where Entities['Type'] =~ \"file\"\n| extend MaliciousFileDirectory = tostring(Entities['Directory']), MaliciousFileName = tostring(Entities['Name']), MaliciousFileHashes = tostring(Entities['FileHashes']);\n//Combine the File and IP data together\nipData\n| join (FileData) on VendorOriginalId\n| summarize by TimeGenerated, AttackerIP, AttackerCountry, DisplayName, ResourceId, AlertType, MaliciousFileDirectory, MaliciousFileName, MaliciousFileHashes\n//Create a type column so we can track if it was a File storage or blobl storage upload\n| extend type = iff(DisplayName has \"file\", \"File\", \"Blob\")\n| join (\n  union\n  StorageFileLogs,\n  StorageBlobLogs\n  //File upload operations\n  | where OperationName =~ \"PutBlob\" or OperationName =~ \"PutRange\"\n  //Parse out the uploader IP\n  | extend ClientIP = tostring(split(CallerIpAddress, \":\", 0)[0])\n  //Extract the filename from the Uri\n  | extend FileName = extract(@\"\\/([\\w\\-. ]+)\\?\", 1, Uri)\n  //Base64 decode the MD5 filehash, we will encounter non-ascii hex so string operations don't work\n  //We can work around this by making it an array then converting it to hex from an int\n  | extend base64Char = base64_decode_toarray(ResponseMd5)\n  | mv-expand base64Char\n  | extend hexChar = tohex(toint(base64Char))\n  | extend hexChar = iff(strlen(hexChar) < 2, strcat(\"0\", hexChar), hexChar)\n  | extend SourceTable = iff(OperationName has \"range\", \"StorageFileLogs\", \"StorageBlobLogs\")\n  | summarize make_list(hexChar, 1000) by CorrelationId, ResponseMd5, FileName, AccountName, TimeGenerated, RequestBodySize, ClientIP, SourceTable\n  | extend Md5Hash = strcat_array(list_hexChar, \"\")\n  //Pack the file information the summarise into a ClientIP row\n  | extend p = pack(\"FileName\", FileName, \"FileSize\", RequestBodySize, \"Md5Hash\", Md5Hash, \"Time\", TimeGenerated, \"SourceTable\", SourceTable)\n  | summarize UploadedFileInfo=make_list(p, 10000), FilesUploaded=count() by ClientIP\n      | join kind=leftouter (\n        union\n        StorageFileLogs,\n        StorageBlobLogs\n        | where OperationName =~ \"DeleteFile\" or OperationName =~ \"DeleteBlob\"\n        | extend ClientIP = tostring(split(CallerIpAddress, \":\", 0)[0])\n        | extend FileName = extract(@\"\\/([\\w\\-. ]+)\\?\", 1, Uri)\n        | extend SourceTable = iff(OperationName has \"range\", \"StorageFileLogs\", \"StorageBlobLogs\")\n        | extend p = pack(\"FileName\", FileName, \"Time\", TimeGenerated, \"SourceTable\", SourceTable)\n        | summarize DeletedFileInfo=make_list(p, 10000), FilesDeleted=count() by ClientIP\n        ) on ClientIP\n  ) on $left.AttackerIP == $right.ClientIP\n| mvexpand UploadedFileInfo\n| extend LinkedMaliciousFileName = tostring(UploadedFileInfo.FileName)\n| extend LinkedMaliciousFileHash = tostring(UploadedFileInfo.Md5Hash)\n| extend HashAlgorithm = \"MD5\"\n| project AlertTimeGenerated = TimeGenerated, LinkedMaliciousFileName, LinkedMaliciousFileHash, HashAlgorithm, AlertType, AttackerIP, AttackerCountry, MaliciousFileDirectory, MaliciousFileName, FilesUploaded, UploadedFileInfo",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CommandAndControl",
                  "Exfiltration"
                ],
                "techniques": [
                  "T1071",
                  "T1567"
                ],
                "templateVersion": "1.0.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/65305b9c-7fd2-400c-ad14-e4cf993efac5')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "Network Port Sweep was detection by multiple IPs",
                  "alertDisplayNameFormat": "Network Port Sweep detected on {{DstPortNumber}}"
                },
                "alertRuleTemplateName": "fcb9d75c-c3c1-4910-8697-f136bfef2363",
                "customDetails": {
                  "AllDstIpAddr": "set_DstIpAddr"
                },
                "description": "This detection rule detects scenarios when a particular port is being scanned by multiple external sources. The rule utilize [ASIM](https://aka.ms/AboutASIM) normalization, and is applied to any source which supports the ASIM Network Session schema.",
                "displayName": "Network Port Sweep from External Network (ASIM Network Session schema)",
                "enabled": false,
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let lookback = 1h;\nlet threshold = 20;\n_Im_NetworkSession(starttime=ago(lookback),endtime=now())\n| where NetworkDirection == \"Inbound\"\n| summarize make_set(DstIpAddr,100) by DstPortNumber\n| where array_length(set_DstIpAddr) > threshold\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Discovery"
                ],
                "techniques": [],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/a88cd032-3e7d-4797-9d73-534e61da8d1a')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "f948a32f-226c-4116-bddd-d95e91d97eb9",
                "description": "This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the MDSec O365 Attack Toolkit (https://github.com/mdsecactivebreach/o365-attack-toolkit).\nThe default permissions/scope for the MDSec O365 Attack toolkit change sometimes but often include contacts.read, user.read, mail.read, notes.read.all, mailboxsettings.readwrite, files.readwrite.all, mail.send, files.read, and files.read.all.\nConsent to applications with these permissions should be rare, especially as the knownApplications list is expanded, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.",
                "displayName": "Suspicious application consent similar to O365 Attack Toolkit",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "GrantIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "CloudApplication",
                    "fieldMappings": [
                      {
                        "columnName": "AppDisplayName",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nlet threshold = 5;\nlet o365_attack_regex = \"contacts.read|user.read|mail.read|notes.read.all|mailboxsettings.readwrite|Files.ReadWrite.All|mail.send|files.read|files.read.all\";\nlet o365_attack = dynamic([\"contacts.read\", \"user.read\", \"mail.read\", \"notes.read.all\", \"mailboxsettings.readwrite\", \"Files.ReadWrite.All\", \"mail.send\", \"files.read\", \"files.read.all\"]);\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend AppDisplayName = tostring(TargetResource.displayName),\n               AppClientId = tostring(TargetResource.id),\n               props = TargetResource.modifiedProperties\n  )\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\"))) // NOTE: a MATCH from this list will cause the alert to NOT fire - please modify for your environment!\n| mv-apply ConsentFull = props on \n  (\n      where ConsentFull.displayName =~ \"ConsentAction.Permissions\"\n  )\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \", CreatedDateTime\" * \"]\" *\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| where ConsentFull has_any (o365_attack)  \n| extend GrantScopeCount = countof(tolower(GrantScope1), o365_attack_regex, 'regex')\n| where GrantScopeCount > threshold\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend GrantUserAgent = AdditionalDetail.value\n  )\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n  | where TimeGenerated > ago(joinLookback)\n  | where LoggedByService =~ \"Core Directory\"\n  | where Category =~ \"ApplicationManagement\"\n  | where OperationName =~ \"Add service principal\"\n  | mv-apply TargetResource = TargetResources on \n      (\n          where TargetResource.type =~ \"ServicePrincipal\"\n          | extend props = TargetResource.modifiedProperties,\n                  AppClientId = tostring(TargetResource.id)\n      )\n  | mv-apply Property = props on \n      (\n          where Property.displayName =~ \"AppAddress\" and Property.newValue has \"AddressType\"\n          | extend AppReplyURLs = trim('\"',tostring(Property.newValue))\n      )\n  | distinct AppClientId, tostring(AppReplyURLs)\n) on AppClientId\n| join kind = innerunique (AuditLogs\n      | where TimeGenerated > ago(joinLookback)\n      | where LoggedByService =~ \"Core Directory\"\n      | where Category =~ \"ApplicationManagement\"\n      | where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n          | mv-apply TargetResource = TargetResources on \n          (\n              where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n              | extend GrantAuthentication = tostring(TargetResource.displayName)\n          )\n      | extend GrantOperation = OperationName\n      | project GrantAuthentication, GrantOperation, CorrelationId\n  ) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend timestamp = TimeGenerated, Name = tostring(split(GrantInitiatedBy,'@',0)[0]), UPNSuffix = tostring(split(GrantInitiatedBy,'@',1)[0])",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess",
                  "DefenseEvasion"
                ],
                "techniques": [
                  "T1528",
                  "T1550"
                ],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b42eebcd-eda3-425b-866f-19cba4aff350')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "a4fb4255-f55b-4c24-b396-976ee075d406",
                "description": "This alert joins SecurityAlerts from Microsoft Products with SecurityIncidents from Microsoft Sentinel and Microsoft 365 Defender. This join allows for identifying patterns in user principal names associated with respective security alerts. A machine learning function (Basket) is leveraged with a .001 threshold. Baset finds all frequent patterns of discrete attributes (dimensions) in the data. It returns the frequent patterns passed the frequency threshold. This query evaluates UserPrincipalName for patterns in SecurityAlerts and Reporting Security Tools. This query can be further tuned/configured for higher confidence percentages, security products, or alert severities pending the needs of the organization. There is an option for configuration of correlations against Microsoft Sentinel watchlists. For more information on the basket plugin, see [basket plugin](https://docs.microsoft.com/azure/data-explorer/kusto/query/basketplugin)",
                "displayName": "Insider Risk_High User Security Alert Correlations",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "AadUserId"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let AlertLinks = SecurityAlert\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize AlertLinks=make_set(AlertLink) by UPN;\nlet LastTimeObserved = SecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| project UPN, AlertName, Severity, ProductName, TimeGenerated | summarize arg_max(AlertName, Severity, ProductName, TimeGenerated) by UPN;\nSecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| project UPN, AlertName, Severity, ProductName\n| evaluate basket(0.001)\n| where UPN <> \"\"\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UPN == $right.SearchKey\n| project UPN, Percent, AlertName, Severity, ProductName\n| join (LastTimeObserved) on UPN\n| sort by Percent desc\n| extend LastObserved = TimeGenerated\n| join kind=inner (AlertLinks) on UPN\n| project UPN, AlertName, Severity, ProductName, Percent, LastObserved, AlertLinks\n| extend AccountCustomEntity = UPN\n",
                "queryFrequency": "P7D",
                "queryPeriod": "P7D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution"
                ],
                "techniques": [],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/a14920d2-5347-4d05-8bb7-0417c5846220')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "e7ec9fa6-e7f7-41ed-a34b-b956837a3ee6",
                "description": "Identifies failed logon attempts from unknown users in Syslog authpriv logs. The unknown user means the account that tried to log in \nisn't provisioned on the machine. A few hits could indicate someone attempting to access a machine they aren't authorized to access. \nIf there are many of hits, especially from outside your network, it could indicate a brute force attack. \nDefault threshold for logon attempts is 15.",
                "displayName": "Failed logon attempts in authpriv",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threshold = 15;\n// Below pulls messages from syslog-authpriv logs where there was an authentication failure with an unknown user.\n// IP address of system attempting logon is also extracted from the SyslogMessage field. Some of these messages\n// are aggregated.\nSyslog\n| where Facility =~ \"authpriv\"\n| where SyslogMessage has \"authentication failure\" and SyslogMessage has \" uid=0\"\n| parse SyslogMessage with * \"rhost=\" RemoteIP\n| project TimeGenerated, Computer, ProcessName, HostIP, RemoteIP, ProcessID\n| join kind=innerunique (\n    // Below pulls messages from syslog-authpriv logs that show each instance an unknown user tried to logon. \n    Syslog \n    | where Facility =~ \"authpriv\"\n    | where SyslogMessage has \"user unknown\"\n    | project Computer, HostIP, ProcessID\n    ) on Computer, HostIP, ProcessID\n// Count the number of failed logon attempts by External IP and internal machine\n| summarize FirstLogonAttempt = min(TimeGenerated), LatestLogonAttempt = max(TimeGenerated), TotalLogonAttempts = count() by Computer, HostIP, RemoteIP\n// Calculate the time between first and last logon attempt (AttemptPeriodLength)\n| extend TimeBetweenLogonAttempts = LatestLogonAttempt - FirstLogonAttempt\n| where TotalLogonAttempts >= threshold\n| project FirstLogonAttempt, LatestLogonAttempt, TimeBetweenLogonAttempts, TotalLogonAttempts, SourceAddress = RemoteIP, DestinationHost = Computer, DestinationAddress = HostIP\n| sort by DestinationHost asc nulls last\n| extend timestamp = FirstLogonAttempt, HostCustomEntity = DestinationHost, IPCustomEntity = DestinationAddress\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1110"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/1b216771-f729-4c6c-803a-76e1f6fdb6ec')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "7b907bf7-77d4-41d0-a208-5643ff75bf9a",
                "description": "Often times after the initial compromise the attackers create inbox rules to delete emails that contain certain keywords.\n This is done so as to limit ability to warn compromised users that they've been compromised. Below is a sample query that tries to detect this.\nReference: https://www.reddit.com/r/sysadmin/comments/7kyp0a/recent_phishing_attempts_my_experience_and_what/",
                "displayName": "Malicious Inbox Rule",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let Keywords = dynamic([\"helpdesk\", \" alert\", \" suspicious\", \"fake\", \"malicious\", \"phishing\", \"spam\", \"do not click\", \"do not open\", \"hijacked\", \"Fatal\"]);\nOfficeActivity\n| where Operation =~ \"New-InboxRule\"\n| where Parameters has \"Deleted Items\" or Parameters has \"Junk Email\"  or Parameters has \"DeleteMessage\"\n| extend Events=todynamic(Parameters)\n| parse Events  with * \"SubjectContainsWords\" SubjectContainsWords '}'*\n| parse Events  with * \"BodyContainsWords\" BodyContainsWords '}'*\n| parse Events  with * \"SubjectOrBodyContainsWords\" SubjectOrBodyContainsWords '}'*\n| where SubjectContainsWords has_any (Keywords)\n or BodyContainsWords has_any (Keywords)\n or SubjectOrBodyContainsWords has_any (Keywords)\n| extend ClientIPAddress = case( ClientIP has \".\", tostring(split(ClientIP,\":\")[0]), ClientIP has \"[\", tostring(trim_start(@'[[]',tostring(split(ClientIP,\"]\")[0]))), ClientIP )\n| extend Keyword = iff(isnotempty(SubjectContainsWords), SubjectContainsWords, (iff(isnotempty(BodyContainsWords),BodyContainsWords,SubjectOrBodyContainsWords )))\n| extend RuleDetail = case(OfficeObjectId contains '/' , tostring(split(OfficeObjectId, '/')[-1]) , tostring(split(OfficeObjectId, '\\\\')[-1]))\n| summarize count(), StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated) by  Operation, UserId, ClientIPAddress, ResultStatus, Keyword, OriginatingServer, OfficeObjectId, RuleDetail\n| extend timestamp = StartTimeUtc,  IPCustomEntity = ClientIPAddress, AccountCustomEntity = UserId , HostCustomEntity =  OriginatingServer",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence",
                  "DefenseEvasion"
                ],
                "techniques": [
                  "T1098",
                  "T1078"
                ],
                "templateVersion": "2.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/d4eaff60-318e-4b64-a96c-bf276011df91')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "ac9e233e-44d4-45eb-b522-6e47445f6582",
                "description": "This detection looks for the steps required to conduct a UAC bypass using Fodhelper.exe. By default this detection looks for the setting of the required registry keys and the invoking of the process within 1 hour - this can be tweaked as required.",
                "displayName": "Potential Fodhelper UAC Bypass (ASIM Version)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "DvcHostname",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "DvcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "ActorUsername",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "imRegistry\n  | where EventType in (\"RegistryValueSet\", \"RegistryKeyCreated\")\n  | where RegistryKey has \"Software\\\\Classes\\\\ms-settings\\\\shell\\\\open\\\\command\"\n  | extend TimeKey = bin(TimeGenerated, 1h)\n  | join (imProcess\n  | where Process endswith \"fodhelper.exe\"\n  | where ParentProcessName endswith \"cmd.exe\" or ParentProcessName endswith \"powershell.exe\" or ParentProcessName endswith \"powershell_ise.exe\"\n  | extend TimeKey = bin(TimeGenerated, 1h)) on TimeKey, Dvc",
                "queryFrequency": "PT2H",
                "queryPeriod": "PT2H",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "PrivilegeEscalation"
                ],
                "techniques": [
                  "T1548"
                ],
                "templateVersion": "1.0.5",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/3abb1e23-3dae-4c58-b9d6-d3f6edc7a7bf')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "48607a29-a26a-4abf-8078-a06dbdd174a4",
                "description": "Identifies evidence of password spray activity against Azure AD applications by looking for failures from multiple accounts from the same\nIP address within a time window. If the number of accounts breaches the threshold just once, all failures from the IP address within the time range\nare bought into the result. Details on whether there were successful authentications by the IP address within the time window are also included.\nThis can be an indicator that an attack was successful.\nThe default failure acccount threshold is 5, Default time window for failures is 20m and default look back window is 3 days\nNote: Due to the number of possible accounts involved in a password spray it is not possible to map identities to a custom entity.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes.",
                "displayName": "Password spray attack against Azure AD application",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let timeRange = 3d;\nlet lookBack = 7d;\nlet authenticationWindow = 20m;\nlet authenticationThreshold = 5;\nlet isGUID = \"[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\";\nlet failureCodes = dynamic([50053, 50126, 50055]); // invalid password, account is locked - too many sign ins, expired password\nlet successCodes = dynamic([0, 50055, 50057, 50155, 50105, 50133, 50005, 50076, 50079, 50173, 50158, 50072, 50074, 53003, 53000, 53001, 50129]);\n// Lookup up resolved identities from last 7 days\nlet aadFunc = (tableName:string){\nlet identityLookup = table(tableName)\n| where TimeGenerated >= ago(lookBack)\n| where not(Identity matches regex isGUID)\n| where isnotempty(UserId)\n| summarize by UserId, lu_UserDisplayName = UserDisplayName, lu_UserPrincipalName = UserPrincipalName, Type;\n// collect window threshold breaches\ntable(tableName)\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(failureCodes)\n| summarize FailedPrincipalCount = dcount(UserPrincipalName) by bin(TimeGenerated, authenticationWindow), IPAddress, AppDisplayName, Type\n| where FailedPrincipalCount >= authenticationThreshold\n| summarize WindowThresholdBreaches = count() by IPAddress, Type\n| join kind= inner (\n// where we breached a threshold, join the details back on all failure data\ntable(tableName)\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(failureCodes)\n| extend LocationDetails = todynamic(LocationDetails)\n| extend FullLocation = strcat(LocationDetails.countryOrRegion,'|', LocationDetails.state, '|', LocationDetails.city)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), make_set(ClientAppUsed,20), make_set(FullLocation,20), FailureCount = count() by IPAddress, AppDisplayName, UserPrincipalName, UserDisplayName, Identity, UserId, Type\n// lookup any unresolved identities\n| extend UnresolvedUserId = iff(Identity matches regex isGUID, UserId, \"\")\n| join kind= leftouter (\n identityLookup\n) on $left.UnresolvedUserId==$right.UserId\n| extend UserDisplayName=iff(isempty(lu_UserDisplayName), UserDisplayName, lu_UserDisplayName)\n| extend UserPrincipalName=iff(isempty(lu_UserPrincipalName), UserPrincipalName, lu_UserPrincipalName)\n| summarize StartTime = min(StartTime), EndTime = max(EndTime), make_set(UserPrincipalName,20), make_set(UserDisplayName,20), make_set(set_ClientAppUsed,20), make_set(set_FullLocation,20), make_list(FailureCount,20) by IPAddress, AppDisplayName, Type\n| extend FailedPrincipalCount = array_length(set_UserPrincipalName)\n) on IPAddress\n| project IPAddress, StartTime, EndTime, TargetedApplication=AppDisplayName, FailedPrincipalCount, UserPrincipalNames=set_UserPrincipalName, UserDisplayNames=set_UserDisplayName, ClientAppsUsed=set_set_ClientAppUsed, Locations=set_set_FullLocation, FailureCountByPrincipal=list_FailureCount, WindowThresholdBreaches, Type\n| join kind= inner (\ntable(tableName) // get data on success vs. failure history for each IP\n| where TimeGenerated > ago(timeRange)\n| where ResultType in(successCodes) or ResultType in(failureCodes) // success or failure types\n| summarize GlobalSuccessPrincipalCount = dcountif(UserPrincipalName, (ResultType in (successCodes))), ResultTypeSuccesses = make_set_if(ResultType, (ResultType in (successCodes))), GlobalFailPrincipalCount = dcountif(UserPrincipalName, (ResultType in (failureCodes))), ResultTypeFailures = make_set_if(ResultType, (ResultType in (failureCodes))) by IPAddress, Type\n| where GlobalFailPrincipalCount > GlobalSuccessPrincipalCount // where the number of failed principals is greater than success - eliminates FPs from IPs who authenticate successfully alot and as a side effect have alot of failures\n) on IPAddress\n| project-away IPAddress1\n| extend timestamp=StartTime\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt",
                "queryFrequency": "P1D",
                "queryPeriod": "P7D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1110"
                ],
                "templateVersion": "1.0.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/0cb768af-eb6b-4774-970e-a52dd3f337be')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "29283b22-a1c0-4d16-b0a9-3460b655a46a",
                "description": "This query uses various log sources having user agent data to look for log4j CVE-2021-44228 exploitation attempt based on user agent pattern. Log4j is an open-source Apache logging library that is used in \n many Java-based applications. The regex and the string matching look for the most common attacks. This might not be comprehensive to detect every possible user agent variation.\n Reference: https://msrc-blog.microsoft.com/2021/12/11/microsofts-response-to-cve-2021-44228-apache-log4j2/",
                "displayName": "User agent search for log4j exploitation attempt",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Url",
                        "identifier": "Url"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SourceIP",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Account",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let UserAgentString = dynamic ([\"${jndi:ldap:/\", \"${jndi:rmi:/\", \"${jndi:ldaps:/\", \"${jndi:dns:/\", \"${jndi:iiop:/\",\"${jndi:\",\"${jndi:nds:/\",\"${jndi:corba/\"]);\nlet UARegexMinimalString=dynamic(['{','%7b', '%7B']);\nlet UARegex = @'(\\\\$|%24)(\\\\{|%7B)([^jJ]*[jJ])([^nN]*[nN])([^dD]*[dD])([^iI]*[iI])(:|%3A|\\\\$|%24|}|%7D)';\n(union isfuzzy=true\n(OfficeActivity\n| where UserAgent has_any (UserAgentString) or UserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = ClientIP, Account = UserId, Type, Operation\n),\n(AzureDiagnostics\n| where Category in (\"FrontdoorWebApplicationFirewallLog\", \"FrontdoorAccessLog\", \"ApplicationGatewayFirewallLog\", \"ApplicationGatewayAccessLog\")\n| where userAgent_s has_any (UserAgentString) or userAgent_s matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent = userAgent_s, SourceIP = clientIP_s, Type, host_s, Url = requestUri_s, httpStatus_d, ruleName_s, transactionId_g, ResourceType, ResourceId\n),\n(\nW3CIISLog\n| where csUserAgent has_any (UserAgentString) or csUserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent = csUserAgent, SourceIP = cIP, Account = csUserName, Type, sSiteName, csMethod, Url = csUriStem\n),\n(\nAWSCloudTrail\n| where UserAgent has_any (UserAgentString) or UserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = SourceIpAddress, Account = UserIdentityUserName, Type, EventName\n),\n(SigninLogs\n| where UserAgent has_any (UserAgentString) or UserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = IPAddress, Account = UserPrincipalName, Type, Operation = OperationName, tostring(LocationDetails), tostring(DeviceDetail),    AppDisplayName, ClientAppUsed\n),\n(AADNonInteractiveUserSignInLogs \n| where UserAgent has_any (UserAgentString) or UserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by UserAgent, SourceIP = IPAddress, Account = UserPrincipalName, Type, Operation = OperationName, tostring(LocationDetails), tostring(DeviceDetail), AppDisplayName, ClientAppUsed\n),\n(_Im_WebSession (httpuseragent_has_any=array_concat(UserAgentString,UARegexMinimalString))\n| where HttpUserAgent has_any (UserAgentString) or HttpUserAgent matches regex UARegex\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by HttpUserAgent, SourceIP = SrcIpAddr, DstIpAddr, Account = SrcUsername, Url, Type\n)\n)",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1190"
                ],
                "templateVersion": "1.0.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/ee613618-f993-4af2-ac5a-ccf66ab73703')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "(MDIoT) {{Description}}",
                  "alertDisplayNameFormat": "(MDIoT) {{AlertName}}",
                  "alertSeverityColumnName": "AlertSeverity",
                  "alertTacticsColumnName": "Tactics"
                },
                "alertRuleTemplateName": "6fb1acd5-356d-40f7-9b97-78d993c6a183",
                "customDetails": {
                  "Protocol": "Protocol",
                  "AlertManagementUri": "AlertManagementUri",
                  "VendorOriginalId": "VendorOriginalId",
                  "Sensor": "DeviceId"
                },
                "description": "This alert leverages Defender for IoT to detect IoT/OT malware found on the network indicating possible attempts to compromise production systems.",
                "displayName": "Suspicious malware found in the network (Microsoft Defender for IoT)",
                "enabled": true,
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let alertList = dynamic([\"Malware\", \"Suspicion of Malicious Activity\", \"Invalid SMB Message (DoublePulsar Backdoor Implant)\", \"Connection Attempt to Known Malicious IP\", \"Malicious Domain Name Request\", \"Suspicion of Remote Code Execution with PsExec\", \"Suspicion of Remote Windows Service Management\", \"Suspicious Executable File Detected on Endpoint\", \"Suspicious Traffic Detected\"]);\nSecurityAlert\n| where ProviderName == \"IoTSecurity\"\n| where AlertName has_any (alertList) \n| extend ExtendedProperties = parse_json(ExtendedProperties)\n| where tostring(ExtendedProperties.isNew) == \"True\"\n| extend DeviceId = tostring(ExtendedProperties.DeviceId), \n         SourceDeviceAddress = tostring(ExtendedProperties.SourceDeviceAddress), \n         DestDeviceAddress = tostring(ExtendedProperties.DestinationDeviceAddress), \n         RemediationSteps = tostring(parse_json(RemediationSteps)[0]), \n         Protocol = tostring(ExtendedProperties.Protocol), \n         AlertManagementUri = tostring(ExtendedProperties.AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri,\n  Techniques\n",
                "queryFrequency": "PT5M",
                "queryPeriod": "PT5M",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [
                  "T0882"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/23003341-8af9-492c-a36e-e34321de1e33')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "bca9c877-2afc-4246-a26d-087ab1cdcd5f",
                "description": "This query looks for file hashes and AV signatures associated with Prestige ransomware \npayload.",
                "displayName": "Prestige ransomware IOCs Oct 2022",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "File",
                    "fieldMappings": [
                      {
                        "columnName": "FileHashCustomEntity",
                        "identifier": "Name"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Process",
                    "fieldMappings": [
                      {
                        "columnName": "ProcessCustomEntity",
                        "identifier": "ProcessId"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "HostName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let sha256Hashes = dynamic([\"5dd1ca0d471dee41eb3ea0b6ea117810f228354fc3b7b47400a812573d40d91d\", \"5fc44c7342b84f50f24758e39c8848b2f0991e8817ef5465844f5f2ff6085a57\", \"6cff0bbd62efe99f381e5cc0c4182b0fb7a9a34e4be9ce68ee6b0d0ea3eee39c\"]);\nlet signames = dynamic([\"Ransom:Win32/Prestige\"]);\n(union isfuzzy=true\n(CommonSecurityLog\n| where FileHash in (sha256Hashes)\n| project TimeGenerated, Message, SourceUserID, FileHash, Type\n| extend timestamp = TimeGenerated, FileHashCustomEntity = 'SHA256', Account = SourceUserID\n),\n(imFileEvent\n| where TargetFileSHA256 has_any (sha256Hashes)\n| extend Account = ActorUsername, Computer = DvcHostname, IPAddress = SrcIpAddr, CommandLine = ActingProcessCommandLine, FileHash = TargetFileSHA256\n| project Type, TimeGenerated, Computer, Account, IPAddress, CommandLine, FileHash\n),\n(Event\n| where Source =~ \"Microsoft-Windows-Sysmon\"\n| where EventID == 1\n| extend EvData = parse_xml(EventData)\n| extend EventDetail = EvData.DataItem.EventData.Data\n| extend Image = EventDetail.[4].[\"#text\"],  CommandLine = EventDetail.[10].[\"#text\"], Hashes = tostring(EventDetail.[17].[\"#text\"])\n| extend Hashes = extract_all(@\"(?P<key>\\w+)=(?P<value>[a-zA-Z0-9]+)\", dynamic([\"key\",\"value\"]), Hashes)\n| extend Hashes = column_ifexists(\"Hashes\", dynamic([\"\", \"\"])), CommandLine = column_ifexists(\"CommandLine\", \"\")\n| mv-expand Hashes\n| where Hashes[0] =~ \"SHA256\" and Hashes[1] has_any (sha256Hashes)  \n| project TimeGenerated, EventDetail, UserName, Computer, Type, Source, Hashes, CommandLine, Image\n| extend Type = strcat(Type, \": \", Source)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer , AccountCustomEntity = UserName, ProcessCustomEntity = tostring(split(Image, '\\\\', -1)[-1]), FileHashCustomEntity = tostring(Hashes[1])\n),\n(DeviceEvents\n| where InitiatingProcessSHA256 has_any (sha256Hashes) or SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = tostring(InitiatingProcessSHA256),  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceFileEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = tostring(InitiatingProcessSHA256),  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(DeviceImageLoadEvents\n| where SHA256 has_any (sha256Hashes)\n| project TimeGenerated, ActionType, DeviceId, DeviceName, InitiatingProcessAccountDomain, InitiatingProcessAccountName, InitiatingProcessCommandLine, InitiatingProcessFolderPath, InitiatingProcessId, InitiatingProcessParentFileName, InitiatingProcessFileName, InitiatingProcessSHA256, Type\n| extend timestamp = TimeGenerated, HostCustomEntity = DeviceName , AccountCustomEntity = InitiatingProcessAccountName, ProcessCustomEntity = InitiatingProcessFileName, AlgorithmCustomEntity = \"SHA256\", FileHashCustomEntity = tostring(InitiatingProcessSHA256),  CommandLine = InitiatingProcessCommandLine,Image = InitiatingProcessFolderPath\n),\n(SecurityAlert\n| where ProductName == \"Microsoft Defender Advanced Threat Protection\"\n| extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n| where isnotempty(ThreatName)\n| where ThreatName has_any (signames)\n| extend Computer = tostring(parse_json(Entities)[0].HostName)\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer\n)\n)",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution"
                ],
                "techniques": [
                  "T1203"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/7378881f-fab0-41b3-a306-08a00ee56767')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "(MDIoT) {{Description}}",
                  "alertDisplayNameFormat": "(MDIoT) {{AlertName}}",
                  "alertSeverityColumnName": "AlertSeverity",
                  "alertTacticsColumnName": "Tactics"
                },
                "alertRuleTemplateName": "e068187a-01f5-4737-bc13-25db4027b7ea",
                "customDetails": {
                  "AlertManagementUri": "AlertManagementUri",
                  "Protocol": "Protocol",
                  "VendorOriginalId": "VendorOriginalId",
                  "Sensor": "DeviceId"
                },
                "description": "This alert leverages Defender for IoT to detect attacks that would prevent the use or proper operation of a DCS system including Denial of Service events.",
                "displayName": "Denial of Service (Microsoft Defender for IoT)",
                "enabled": true,
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityAlert\n| where ProviderName == \"IoTSecurity\"\n| where AlertName == \"Suspicion of Denial Of Service Attack\"\n| extend ExtendedProperties = parse_json(ExtendedProperties)\n| where tostring(ExtendedProperties.isNew) == \"True\"\n| extend DeviceId = tostring(ExtendedProperties.DeviceId), \n         SourceDeviceAddress = tostring(ExtendedProperties.SourceDeviceAddress), \n         DestDeviceAddress = tostring(ExtendedProperties.DestinationDeviceAddress), \n         RemediationSteps = tostring(parse_json(RemediationSteps)[0]), \n         Protocol = tostring(ExtendedProperties.Protocol), \n         AlertManagementUri = tostring(ExtendedProperties.AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri,\n  Techniques\n",
                "queryFrequency": "PT5M",
                "queryPeriod": "PT5M",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InhibitResponseFunction"
                ],
                "techniques": [
                  "T0814"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/083ab654-ebf0-4d2c-ab1a-e0c6bb68d9f8')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active\nDirectory application and picks out the most anomalous change in location profile for a user within an\nindividual application. This has detected {{UserPrincipalName}} signing into {{AppDisplayName}} from {{CountOfLocations}} \ndifferent locations.\n",
                  "alertDisplayNameFormat": "Anomalous sign-in location by {{UserPrincipalName}} to {{AppDisplayName}}"
                },
                "alertRuleTemplateName": "7cb8f77d-c52f-4e46-b82f-3cf2e106224a",
                "customDetails": {
                  "Application": "AppDisplayName"
                },
                "description": "This query over Azure Active Directory sign-in considers all user sign-ins for each Azure Active\nDirectory application and picks out the most anomalous change in location profile for a user within an\nindividual application.",
                "displayName": "Anomalous sign-in location by user account and authenticating application",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      },
                      {
                        "columnName": "UserId",
                        "identifier": "AadUserId"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "// Adjust this figure to adjust how sensitive this detection is\nlet sensitivity = 2.5;\nlet AuthEvents = materialize(\nunion isfuzzy=True SigninLogs, AADNonInteractiveUserSignInLogs\n| where TimeGenerated > ago(7d)\n| where ResultType == 0\n| extend LocationDetails = LocationDetails_dynamic\n| extend Location = strcat(LocationDetails.countryOrRegion, \"-\", LocationDetails.state,\"-\", LocationDetails.city)\n| where Location != \"--\");\nAuthEvents\n| summarize dcount(Location) by AppDisplayName, AppId, UserPrincipalName, UserId, bin(startofday(TimeGenerated), 1d)\n| where dcount_Location > 2\n| summarize CountOfLocations = make_list(dcount_Location, 10000), TimeStamp = make_list(TimeGenerated, 10000) by AppId, UserId\n| extend (Anomalies, Score, Baseline) = series_decompose_anomalies(CountOfLocations, sensitivity, -1, 'linefit')\n| mv-expand CountOfLocations to typeof(double), TimeStamp to typeof(datetime), Anomalies to typeof(double), Score to typeof(double), Baseline to typeof(long)\n| where Anomalies > 0\n| join kind=inner( AuthEvents | extend TimeStamp = startofday(TimeGenerated)) on UserId, AppId\n| extend SignInDetails = bag_pack(\"TimeGenerated\", TimeGenerated, \"Location\", Location, \"Source\", IPAddress, \"Device\", DeviceDetail_dynamic)\n| summarize SignInDetailsSet=make_set(SignInDetails, 1000) by UserId, UserPrincipalName, CountOfLocations, TimeStamp, AppId, AppDisplayName\n| extend Name = split(UserPrincipalName, \"@\")[0], UPNSuffix = split(UserPrincipalName, \"@\")[1]",
                "queryFrequency": "P1D",
                "queryPeriod": "P7D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "2.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/abf2defc-50a7-4849-9bff-e591d1f54722')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "4b11568b-3f5f-4ba1-80c8-7f1dc8390eb7",
                "description": "Identifies when the volume of documents uploaded to or downloaded from Sharepoint by new IP addresses\nexceeds a threshold (default is 50).",
                "displayName": "SharePointFileOperation via previously unseen IPs",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "URLCustomEntity",
                        "identifier": "Url"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threshold = 50;\nlet szSharePointFileOperation = \"SharePointFileOperation\";\nlet szOperations = dynamic([\"FileDownloaded\", \"FileUploaded\"]);\nlet starttime = 14d;\nlet endtime = 1d;\nlet historicalActivity =\nOfficeActivity\n| where TimeGenerated between(ago(starttime)..ago(endtime))\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| summarize historicalCount = count() by ClientIP, RecordType, Operation;\nlet recentActivity = OfficeActivity\n| where TimeGenerated > ago(endtime)\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| summarize min(Start_Time), max(Start_Time), recentCount = count() by ClientIP, RecordType, Operation;\nlet RareIP = recentActivity | join kind= leftanti ( historicalActivity ) on ClientIP, RecordType, Operation\n// More than 50 downloads/uploads from a new IP\n| where recentCount > threshold;\nOfficeActivity\n| where TimeGenerated >= ago(endtime)\n| where RecordType =~ szSharePointFileOperation\n| where Operation in~ (szOperations)\n| join kind= inner (RareIP) on ClientIP, RecordType, Operation\n| where Start_Time between(min_Start_Time .. max_Start_Time)\n| summarize StartTimeUtc = min(min_Start_Time), EndTimeUtc = max(max_Start_Time) by RecordType, Operation, UserType, UserId, ClientIP, OfficeWorkload, Site_Url, OfficeObjectId, UserAgent, IPSeenCount = recentCount\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP, URLCustomEntity = Site_Url\n| order by IPSeenCount desc, ClientIP asc, Operation asc, UserId asc",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Exfiltration"
                ],
                "techniques": [
                  "T1030"
                ],
                "templateVersion": "2.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/998554c2-1b91-4d1b-a229-5bb123605510')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "(MDIoT) {{Description}}",
                  "alertDisplayNameFormat": "(MDIoT) {{AlertName}}",
                  "alertSeverityColumnName": "AlertSeverity",
                  "alertTacticsColumnName": "Tactics"
                },
                "alertRuleTemplateName": "1ff4fa3d-150b-4c87-b733-26c289af0d49",
                "customDetails": {
                  "Protocol": "Protocol",
                  "AlertManagementUri": "AlertManagementUri",
                  "VendorOriginalId": "VendorOriginalId",
                  "Sensor": "DeviceId"
                },
                "description": "This alert leverages Defender for IoT to detect unauthorized remote access to network devices, if another device on the network is compromised, target devices can be accessed remotely, increasing the attack surface.",
                "displayName": "Unauthorized remote access to the network (Microsoft Defender for IoT)",
                "enabled": true,
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityAlert\n| where ProviderName == \"IoTSecurity\"\n| where AlertName == \"Unauthorized SSH Access\"\n| extend ExtendedProperties = parse_json(ExtendedProperties)\n| where tostring(ExtendedProperties.isNew) == \"True\"\n| extend DeviceId = tostring(ExtendedProperties.DeviceId), \n         SourceDeviceAddress = tostring(ExtendedProperties.SourceDeviceAddress), \n         DestDeviceAddress = tostring(ExtendedProperties.DestinationDeviceAddress), \n         RemediationSteps = tostring(parse_json(RemediationSteps)[0]), \n         Protocol = tostring(ExtendedProperties.Protocol), \n         AlertManagementUri = tostring(ExtendedProperties.AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri,\n  Techniques\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T0886"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/e637c99e-e503-4733-92ce-b9174ff1f77e')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "6dd2629c-534b-4275-8201-d7968b4fa77e",
                "description": "This query detects attempts by malware to hide the scheduled task by deleting the SD (Security Descriptor) value. Removal of SD value results in the scheduled task disappearing from schtasks /query and Task Scheduler.\n The query requires auditing to be turned on for HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree registry hive as well as audit policy for registry auditing to be turned on.\n Reference: https://www.microsoft.com/security/blog/2022/04/12/tarrask-malware-uses-scheduled-tasks-for-defense-evasion/\n Reference: https://4sysops.com/archives/audit-changes-in-the-windows-registry/",
                "displayName": "Scheduled Task Hide",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityEvent\n| where EventID == 4657\n| extend EventData = parse_xml(EventData).EventData.Data\n| mv-expand bagexpansion=array EventData\n| evaluate bag_unpack(EventData)\n| extend Key = tostring(column_ifexists('@Name', \"\")), Value = column_ifexists('#text', \"\")\n| evaluate pivot(Key, any(Value), TimeGenerated, TargetAccount, Computer, EventSourceName, Channel, Task, Level, EventID, Activity, TargetLogonId, SourceComputerId, EventOriginId, Type, _ResourceId, TenantId, SourceSystem, ManagementGroupName, IpAddress, Account)\n| extend ObjectName = column_ifexists('ObjectName', \"\"), OperationType = column_ifexists('OperationType', \"\"), ObjectValueName = column_ifexists('ObjectValueName', \"\")\n| where ObjectName has 'Schedule\\\\TaskCache\\\\Tree' and ObjectValueName == \"SD\" and OperationType == \"%%1906\"  // %%1906 - Registry value deleted\n| extend timestamp = TimeGenerated, HostCustomEntity = Computer, AccountCustomEntity = Account\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "DefenseEvasion"
                ],
                "techniques": [],
                "templateVersion": "1.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/d24a52f4-f870-48cb-93a0-c1da215d8994')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "A client with address {{SrcIpAddr}} generated a large number of failed authentication HTTP requests. This may indicate a [brute force](https://en.wikipedia.org/wiki/Brute-force_attack) or [credential stuffing](https://en.wikipedia.org/wiki/Credential_stuffing) attack.",
                  "alertDisplayNameFormat": "Excessive number of HTTP authentication failures from {{SrcIpAddr}"
                },
                "alertRuleTemplateName": "a1bddaf8-982b-4089-ba9e-6590dfcf80ea",
                "customDetails": {
                  "NumberOfErrors": "NumberOfErrors"
                },
                "description": "This rule identifies a source that repeatedly fails to authenticate to a web service (HTTP response code 403). This may indicate a [brute force](https://en.wikipedia.org/wiki/Brute-force_attack) or [credential stuffing](https://en.wikipedia.org/wiki/Credential_stuffing) attack.<br><br>\nThis rule uses the [Advanced Security Information Model (ASIM)](https://aka.ms/AboutSIM) and supports any web session source that complies with ASIM.",
                "displayName": "Excessive number of HTTP authentication failures from a source (ASIM Web Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Url",
                        "identifier": "Url"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let error403_count_threshold=200;\n_Im_WebSession(eventresultdetails_in=dynamic([\"403\"]))\n| extend ParsedUrl=parse_url(Url)\n| extend UrlHost=tostring(ParsedUrl[\"Host\"]), UrlSchema=tostring(ParsedUrl[\"Schema\"])\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), NumberOfErrors = count(), Urls=makeset(Url) by UrlHost, SrcIpAddr\n| where NumberOfErrors > error403_count_threshold\n| sort by NumberOfErrors desc\n| extend Url=tostring(Urls[0])",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Low",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence",
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1110",
                  "T1556"
                ],
                "templateVersion": "1.0.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/718ab67f-0c86-4b48-86d6-0445dd287ee1')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "500415fb-bba7-4227-a08a-9857fb61b6a7",
                "description": "Identifies when Exchange Online transport rule configured to forward emails.\nThis could be an adversary mailbox configured to collect mail from multiple user accounts.",
                "displayName": "Mail redirect via ExO transport rule",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "OfficeActivity\n| where OfficeWorkload == \"Exchange\"\n| where Operation in~ (\"New-TransportRule\", \"Set-TransportRule\")\n| mv-apply DynamicParameters = todynamic(Parameters) on (summarize ParsedParameters = make_bag(pack(tostring(DynamicParameters.Name), DynamicParameters.Value)))\n| extend RuleName = case(\n    Operation =~ \"Set-TransportRule\", OfficeObjectId,\n    Operation =~ \"New-TransportRule\", ParsedParameters.Name,\n    \"Unknown\")\n| mv-expand ExpandedParameters = todynamic(Parameters)\n| where ExpandedParameters.Name in~ (\"BlindCopyTo\", \"RedirectMessageTo\") and isnotempty(ExpandedParameters.Value)\n| extend RedirectTo = ExpandedParameters.Value\n| extend ClientIPValues = extract_all(@'\\[?(::ffff:)?(?P<IPAddress>(\\d+\\.\\d+\\.\\d+\\.\\d+)|[^\\]]+)\\]?([-:](?P<Port>\\d+))?', dynamic([\"IPAddress\", \"Port\"]), ClientIP)[0]\n| project TimeGenerated, RedirectTo, IPAddress = tostring(ClientIPValues[0]), Port = tostring(ClientIPValues[1]), UserId, Operation, RuleName, Parameters\n| extend timestamp = TimeGenerated, AccountCustomEntity = UserId, IPCustomEntity = IPAddress\n    \n",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Collection",
                  "Exfiltration"
                ],
                "techniques": [],
                "templateVersion": "2.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/4bde2ab2-cbe3-48e1-ae51-aa427ccec63f')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "2cfc3c6e-f424-4b88-9cc9-c89f482d016a",
                "description": "This will alert when an admin or app owner account adds a new credential to an Application or Service Principal where there was no previous verify KeyCredential associated.\nIf a threat actor obtains access to an account with sufficient privileges and adds the alternate authentication material triggering this event, the threat actor can now authenticate as the Application or Service Principal using this credential.\nAdditional information on OAuth Credential Grants can be found in RFC 6749 Section 4.4 or https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.",
                "displayName": "First access credential added to Application or Service Principal where no credential was present",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatingIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "CloudApplication",
                    "fieldMappings": [
                      {
                        "columnName": "targetDisplayName",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where OperationName has (\"Certificates and secrets management\")\n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"Application\"\n      | extend targetDisplayName = tostring(TargetResource.displayName),\n               targetId = tostring(TargetResource.id),\n               targetType = tostring(TargetResource.type),\n               keyEvents = TargetResource.modifiedProperties\n  )\n| mv-apply Property = keyEvents on \n  (\n      where Property.displayName =~ \"KeyDescription\"\n      | extend new_value_set = parse_json(tostring(Property.newValue)),\n               old_value_set = parse_json(tostring(Property.oldValue))\n  )\n| where old_value_set == \"[]\"  \n| mv-expand new_value_set\n| parse new_value_set with * \"KeyIdentifier=\" keyIdentifier:string \",KeyType=\" keyType:string \",KeyUsage=\" keyUsage:string \",DisplayName=\" keyDisplayName:string \"]\" *\n| where keyUsage =~ \"Verify\"\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| project-away new_value_set, old_value_set\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, InitiatingIpAddress, UserAgent, targetDisplayName, targetId, targetType, keyDisplayName, keyType, keyUsage, keyIdentifier, CorrelationId, TenantId\n| extend timestamp = TimeGenerated, Name = tostring(split(InitiatingUserOrApp,'@',0)[0]), UPNSuffix = tostring(split(InitiatingUserOrApp,'@',1)[0])",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "DefenseEvasion"
                ],
                "techniques": [
                  "T1550"
                ],
                "templateVersion": "1.1.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/6d954120-e730-49d1-82e7-30b2ebf8d575')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "(MDIoT) {{Description}}",
                  "alertDisplayNameFormat": "(MDIoT) {{AlertName}}",
                  "alertSeverityColumnName": "AlertSeverity",
                  "alertTacticsColumnName": "Tactics"
                },
                "alertRuleTemplateName": "493916d5-a094-4bfa-bdd1-d983a063ea3d",
                "customDetails": {
                  "AlertManagementUri": "AlertManagementUri",
                  "VendorOriginalId": "VendorOriginalId",
                  "Protocol": "Protocol",
                  "Sensor": "DeviceId"
                },
                "description": "This alert leverages Defender for IoT to detect multiple scans on the network indicating new devices, functionality, application misconfiguration, or malicious reconnaissance activity on the network.",
                "displayName": "Multiple scans in the network (Microsoft Defender for IoT)",
                "enabled": true,
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityAlert\n| where ProviderName == \"IoTSecurity\"\n| where AlertName has \"Scan\"\n| extend ExtendedProperties = parse_json(ExtendedProperties)\n| where tostring(ExtendedProperties.isNew) == \"True\"\n| extend DeviceId = tostring(ExtendedProperties.DeviceId), \n         SourceDeviceAddress = tostring(ExtendedProperties.SourceDeviceAddress), \n         DestDeviceAddress = tostring(ExtendedProperties.DestinationDeviceAddress), \n         RemediationSteps = tostring(parse_json(RemediationSteps)[0]), \n         Protocol = tostring(ExtendedProperties.Protocol), \n         AlertManagementUri = tostring(ExtendedProperties.AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri,\n  Techniques\n",
                "queryFrequency": "PT5M",
                "queryPeriod": "PT5M",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Discovery"
                ],
                "techniques": [
                  "T0842"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/c14a01f0-ef23-426e-90c0-b9df8c869f65')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "2560515c-07d1-434e-87fb-ebe3af267760",
                "description": "This query look for applications that have been granted (Delegated or App/Role) permissions to Read Mail (Permissions field has Mail.Read) and subsequently has been consented to. This can help identify applications that have been abused to gain access to mailboxes.",
                "displayName": "Mail.Read Permissions Granted to Application",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "UserIPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where Category =~ \"ApplicationManagement\"\n| where ActivityDisplayName has_any (\"Add delegated permission grant\",\"Add app role assignment to service principal\")  \n| where Result =~ \"success\"\n| where tostring(InitiatedBy.user.userPrincipalName) has \"@\" or tostring(InitiatedBy.app.displayName) has \"@\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n      | extend props = TargetResource.modifiedProperties,\n               Type = tostring(TargetResource.type),\n               PermissionsAddedTo = tostring(TargetResource.displayName)\n  )\n| mv-apply Property = props on \n  (\n      where Property.displayName =~ \"DelegatedPermissionGrant.Scope\"\n      | extend DisplayName = tostring(Property.displayName), Permissions = trim('\"',tostring(Property.newValue))\n  )\n| where Permissions has_any (\"Mail.Read\", \"Mail.ReadWrite\")\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingUser = tostring(InitiatedBy.user.userPrincipalName)\n| extend UserIPAddress = tostring(InitiatedBy.user.ipAddress)  \n| project-away props, TargetResource*, AdditionalDetail*, Property, InitiatedBy\n| join kind=leftouter(\n  AuditLogs\n  | where ActivityDisplayName has \"Consent to application\"\n  | mv-apply TargetResource = TargetResources on \n      (\n          where TargetResource.type =~ \"ServicePrincipal\"\n          | extend AppName = tostring(TargetResource.displayName),\n                   AppId = tostring(TargetResource.id)\n      )\n  | project AppName, AppId, CorrelationId) on CorrelationId\n| project-reorder TimeGenerated, OperationName, InitiatingUser, UserIPAddress, UserAgent, PermissionsAddedTo, Permissions, AppName, AppId, CorrelationId\n| extend timestamp = TimeGenerated, Name = tostring(split(InitiatingUser,'@',0)[0]), UPNSuffix = tostring(split(InitiatingUser,'@',1)[0])",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence"
                ],
                "techniques": [
                  "T1098"
                ],
                "templateVersion": "1.0.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/c9e64171-af63-4e20-b9c2-62914776a89c')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "c094384d-7ea7-4091-83be-18706ecca981",
                "description": "Identifies IP addresses that may be performing DNS lookups associated with common currency mining pools.\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema",
                "displayName": "DNS events related to mining pools (ASIM DNS Schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let minersDomains=dynamic([\"monerohash.com\", \"do-dear.com\", \"xmrminerpro.com\", \"secumine.net\", \"xmrpool.com\", \"minexmr.org\", \"hashanywhere.com\", \n\"xmrget.com\", \"mininglottery.eu\", \"minergate.com\", \"moriaxmr.com\", \"multipooler.com\", \"moneropools.com\", \"xmrpool.eu\", \"coolmining.club\", \n\"supportxmr.com\", \"minexmr.com\", \"hashvault.pro\", \"xmrpool.net\", \"crypto-pool.fr\", \"xmr.pt\", \"miner.rocks\", \"walpool.com\", \"herominers.com\", \n\"gntl.co.uk\", \"semipool.com\", \"coinfoundry.org\", \"cryptoknight.cc\", \"fairhash.org\", \"baikalmine.com\", \"tubepool.xyz\", \"fairpool.xyz\", \"asiapool.io\", \n\"coinpoolit.webhop.me\", \"nanopool.org\", \"moneropool.com\", \"miner.center\", \"prohash.net\", \"poolto.be\", \"cryptoescrow.eu\", \"monerominers.net\", \"cryptonotepool.org\", \n\"extrmepool.org\", \"webcoin.me\", \"kippo.eu\", \"hashinvest.ws\", \"monero.farm\", \"supportxmr.com\", \"xmrpool.eu\", \"linux-repository-updates.com\", \"1gh.com\", \n\"dwarfpool.com\", \"hash-to-coins.com\", \"hashvault.pro\", \"pool-proxy.com\", \"hashfor.cash\", \"fairpool.cloud\", \"litecoinpool.org\", \"mineshaft.ml\", \"abcxyz.stream\", \n\"moneropool.ru\", \"cryptonotepool.org.uk\", \"extremepool.org\", \"extremehash.com\", \"hashinvest.net\", \"unipool.pro\", \"crypto-pools.org\", \"monero.net\", \n\"backup-pool.com\", \"mooo.com\", \"freeyy.me\", \"cryptonight.net\", \"shscrypto.net\"]);\n_Im_Dns(domain_has_any=minersDomains)\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr, HostCustomEntity = Dvc",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Low",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [
                  "T1496"
                ],
                "templateVersion": "1.3.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b572e11e-7cc4-41b2-bee1-74d89a8d4157')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "78422ef2-62bf-48ca-9bab-72c69818a425",
                "description": "Identifies when an RDP connection is made to multiple systems and above the normal for the previous 7 days.\nConnections from the same system with the same account within the same day.\nRDP connections are indicated by the EventID 4624 with LogonType = 10",
                "displayName": "Multiple RDP connections from Single System",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let endtime = 1d;\nlet starttime = 8d;\nlet threshold = 2.0;\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624 and LogonType == 10\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerCountToday = dcount(Computer), ComputerSet = makeset(Computer), ProcessSet = makeset(ProcessName)\nby Account, IpAddress, AccountType, Activity, LogonTypeName),\n(WindowsEvent\n| where TimeGenerated >= ago(endtime)\n| where EventID == 4624\n| extend LogonType = tostring(EventData.LogonType)\n| where  LogonType == 10\n| extend ProcessName = tostring(EventData.ProcessName)\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend IpAddress = tostring(EventData.IpAddress)\n| extend TargetUserSid = tostring(EventData.TargetUserSid)\n| extend AccountType=case(Account endswith \"$\" or TargetUserSid in (\"S-1-5-18\", \"S-1-5-19\", \"S-1-5-20\"), \"Machine\", isempty(TargetUserSid), \"\", \"User\")\n| extend Activity=\"4624 - An account was successfully logged on.\"\n| extend LogonTypeName=\"10 - RemoteInteractive\"\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), ComputerCountToday = dcount(Computer), ComputerSet = makeset(Computer), ProcessSet = makeset(ProcessName)\nby Account, IpAddress, AccountType, Activity, LogonTypeName)\n)\n| join kind=inner (\n(union isfuzzy=true\n(SecurityEvent\n| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)\n| where EventID == 4624 and LogonType == 10\n| summarize ComputerCountPrev7Days = dcount(Computer) by Account = tolower(Account), IpAddress\n),\n( WindowsEvent\n| where TimeGenerated >= ago(starttime) and TimeGenerated < ago(endtime)\n| where EventID == 4624  and EventData has (\"10\")\n| extend LogonType = toint(EventData.LogonType)\n| where  LogonType == 10\n| extend Account = strcat(tostring(EventData.TargetDomainName),\"\\\\\", tostring(EventData.TargetUserName))\n| extend IpAddress = tostring(EventData.IpAddress)\n| summarize ComputerCountPrev7Days = dcount(Computer) by Account = tolower(Account), IpAddress)\n)\n) on Account, IpAddress\n| extend Ratio = iff(isempty(ComputerCountPrev7Days), toreal(ComputerCountToday), ComputerCountToday / (ComputerCountPrev7Days * 1.0))\n// Where the ratio of today to previous 7 days is more than double.\n| where Ratio > threshold\n| project StartTimeUtc, EndTimeUtc, Account, IpAddress, ComputerSet, ComputerCountToday, ComputerCountPrev7Days, Ratio, AccountType, Activity, LogonTypeName, ProcessSet\n| extend timestamp = StartTimeUtc, AccountCustomEntity = Account, IPCustomEntity = IpAddress",
                "queryFrequency": "P1D",
                "queryPeriod": "P8D",
                "severity": "Low",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "LateralMovement"
                ],
                "techniques": [
                  "T1021"
                ],
                "templateVersion": "1.2.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/2583689a-2810-4622-b98b-52492994a4eb')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "NRT",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "8540c842-5bbc-4a24-9fb2-a836c0e55a51",
                "description": "This will alert when a user or application modifies the federation settings on the domain or Update domain authentication from Managed to Federated.\nFor example, this alert will trigger when a new Active Directory Federated Service (ADFS) TrustedRealm object, such as a signing certificate, is added to the domain.\nModification to domain federation settings should be rare. Confirm the added or modified target domain/URL is legitimate administrator behavior.\nTo understand why an authorized user may update settings for a federated domain in Office 365, Azure, or Intune, see: https://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365.\nFor details on security realms that accept security tokens, see the ADFS Proxy Protocol (MS-ADFSPP) specification: https://docs.microsoft.com/openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.",
                "displayName": "NRT Modified domain federation trust settings",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatingUserOrApp",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatingIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where OperationName =~ \"Set federation settings on domain\" or OperationName =~ \"Set domain authentication\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| extend targetDisplayName = tostring(parse_json(modifiedProperties).displayName), NewDomainValue=tostring(parse_json(modifiedProperties).newValue)\n| extend Federated = iif(OperationName =~ \"Set domain authentication\", iif(NewDomainValue has \"Federated\", True, False), True)\n| where Federated == True\n| mv-expand AdditionalDetails\n| extend UserAgent = iff(AdditionalDetails.key == \"User-Agent\",tostring(AdditionalDetails.value),\"\")\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, AADOperationType, targetDisplayName, Result, InitiatingIpAddress, UserAgent, CorrelationId, TenantId, AADTenantId\n",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [],
                "templateVersion": "1.0.0"
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/c931529c-384d-4758-b2dc-b60753dfa646')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "95dc4ae3-e0f2-48bd-b996-cdd22b90f9af",
                "description": "This will alert when a user or application modifies the federation settings on the domain or Update domain authentication from Managed to Federated.\nFor example, this alert will trigger when a new Active Directory Federated Service (ADFS) TrustedRealm object, such as a signing certificate, is added to the domain.\nModification to domain federation settings should be rare. Confirm the added or modified target domain/URL is legitimate administrator behavior.\nTo understand why an authorized user may update settings for a federated domain in Office 365, Azure, or Intune, see: https://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365.\nFor details on security realms that accept security tokens, see the ADFS Proxy Protocol (MS-ADFSPP) specification: https://docs.microsoft.com/openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.",
                "displayName": "Modified domain federation trust settings",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatingIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "(union isfuzzy=true\n(\nAuditLogs\n| where OperationName =~ \"Set federation settings on domain\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| extend targetDisplayName = tostring(parse_json(modifiedProperties).displayName)\n),\n(\nAuditLogs\n| where OperationName =~ \"Set domain authentication\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-expand modifiedProperties\n| mv-apply Property = modifiedProperties on \n  (\n      where Property.displayName =~ \"LiveType\"\n      | extend targetDisplayName = tostring(Property.displayName),\n               NewDomainValue = tostring(Property.newValue)\n  )\n| where NewDomainValue has \"Federated\"\n)\n)\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, AADOperationType, targetDisplayName, Result, InitiatingIpAddress, UserAgent, CorrelationId, TenantId, AADTenantId\n| extend timestamp = TimeGenerated, Name = tostring(split(InitiatingUserOrApp,'@',0)[0]), UPNSuffix = tostring(split(InitiatingUserOrApp,'@',1)[0])\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/2aa2bee6-9544-4d39-9328-c9d83234018d')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "39198934-62a0-4781-8416-a81265c03fd6",
                "description": "This will alert when a user consents to provide a previously-unknown Azure application with the same OAuth permissions used by the FireEye PwnAuth toolkit (https://github.com/fireeye/PwnAuth).\nThe default permissions/scope for the PwnAuth toolkit are user.read, offline_access, mail.readwrite, mail.send, and files.read.all.\nConsent to applications with these permissions should be rare, especially as the knownApplications list is expanded. Public contributions to expand this filter are welcome!\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.",
                "displayName": "Suspicious application consent similar to PwnAuth",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "GrantIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let detectionTime = 1d;\nlet joinLookback = 14d;\nAuditLogs\n| where TimeGenerated > ago(detectionTime)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Consent to application\"\n| where TargetResources has \"offline\"\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend AppDisplayName = tostring(TargetResource.displayName),\n               AppClientId = tostring(TargetResource.id),\n               props = TargetResource.modifiedProperties\n  )\n| where AppClientId !in ((externaldata(knownAppClientId:string, knownAppDisplayName:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/Microsoft.OAuth.KnownApplications.csv\"] with (format=\"csv\")))\n| mv-apply ConsentFull = props on \n  (\n      where ConsentFull.displayName =~ \"ConsentAction.Permissions\"\n  )\n| parse ConsentFull with * \"ConsentType: \" GrantConsentType \", Scope: \" GrantScope1 \"]\" *\n| where ConsentFull has_all (\"user.read\", \"offline_access\", \"mail.readwrite\", \"mail.send\", \"files.read.all\")\n| where GrantConsentType != \"AllPrincipals\" // NOTE: we are ignoring if OAuth application was granted to all users via an admin - but admin due diligence should be audited occasionally\n| extend GrantIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| extend GrantInitiatedBy = iff(isnotempty(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend GrantUserAgent = AdditionalDetail.value\n  )\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, GrantIpAddress, GrantUserAgent, AppClientId, OperationName, ConsentFull, CorrelationId\n| join kind = leftouter (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add service principal\"\n  | mv-apply TargetResource = TargetResources on \n      (\n          where TargetResource.type =~ \"ServicePrincipal\"\n          | extend props = TargetResource.modifiedProperties,\n                  AppClientId = tostring(TargetResource.id)\n      )\n  | mv-apply Property = props on \n      (\n          where Property.displayName =~ \"AppAddress\" and Property.newValue has \"AddressType\"\n          | extend AppReplyURLs = trim('\"',tostring(Property.newValue))\n      )\n| distinct AppClientId, tostring(AppReplyURLs)\n)\non AppClientId\n| join kind = innerunique (AuditLogs\n| where TimeGenerated > ago(joinLookback)\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where OperationName =~ \"Add OAuth2PermissionGrant\" or OperationName =~ \"Add delegated permission grant\"\n      | mv-apply TargetResource = TargetResources on \n          (\n              where TargetResource.type =~ \"ServicePrincipal\" and array_length(TargetResource.modifiedProperties) > 0 and isnotnull(TargetResource.displayName)\n              | extend GrantAuthentication = tostring(TargetResource.displayName)\n          )\n| extend GrantOperation = OperationName\n| project GrantAuthentication, GrantOperation, CorrelationId\n) on CorrelationId\n| project TimeGenerated, GrantConsentType, GrantScope1, GrantInitiatedBy, AppDisplayName, AppReplyURLs, GrantIpAddress, GrantUserAgent, AppClientId, GrantAuthentication, OperationName, GrantOperation, CorrelationId, ConsentFull\n| extend timestamp = TimeGenerated, Name = tostring(split(GrantInitiatedBy,'@',0)[0]), UPNSuffix = tostring(split(GrantInitiatedBy,'@',1)[0])\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess",
                  "DefenseEvasion"
                ],
                "techniques": [
                  "T1528",
                  "T1550"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b0292e04-95de-42d6-a024-68b43aba754b')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "f80d951a-eddc-4171-b9d0-d616bb83efdc",
                "description": "This rule looks for a service principal being granted the Microsoft Graph RoleManagement.ReadWrite.Directory (application) permission before being used to add an Azure AD object or user account to an Admin directory role (i.e. Global Administrators).\nThis is a known attack path that is usually abused when a service principal already has the AppRoleAssignment.ReadWrite.All permission granted. This permission Allows an app to manage permission grants for application permissions to any API.\nA service principal can promote itself or other service principals to admin roles (i.e. Global Administrators). This would be considered a privilege escalation technique.\nRef : https://docs.microsoft.com/graph/permissions-reference#role-management-permissions, https://docs.microsoft.com/graph/api/directoryrole-post-members?view=graph-rest-1.0&tabs=http",
                "displayName": "Admin promotion after Role Management Application Permission Grant",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "ServicePrincipal",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "TargetObject",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where LoggedByService =~ \"Core Directory\"\n| where Category =~ \"ApplicationManagement\"\n| where AADOperationType =~ \"Assign\"\n| where ActivityDisplayName =~ \"Add app role assignment to service principal\"\n| mv-expand TargetResources\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ =~ \"AppRole.Value\"\n| extend AppRole = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n| where AppRole has \"RoleManagement.ReadWrite.Directory\"\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| extend Target = tostring(parse_json(tostring(TargetResources.modifiedProperties[4].newValue)))\n| extend TargetId = tostring(parse_json(tostring(TargetResources.modifiedProperties[3].newValue)))\n| project TimeGenerated, OperationName, Initiator, Target, TargetId, Result\n| join kind=innerunique (\n  AuditLogs\n  | where LoggedByService =~ \"Core Directory\"\n  | where Category =~ \"RoleManagement\"\n  | where AADOperationType in (\"Assign\", \"AssignEligibleRole\")\n  | where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n  | mv-expand TargetResources\n  | mv-expand TargetResources.modifiedProperties\n  | extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n  | where displayName_ =~ \"Role.DisplayName\"\n  | extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n  | where RoleName contains \"Admin\"\n  | extend Initiator = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n  | extend InitiatorId = tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalId)\n  | extend TargetUser = tostring(TargetResources.userPrincipalName)\n  | extend Target = iif(isnotempty(TargetUser), TargetUser, tostring(TargetResources.displayName))\n  | extend TargetType = tostring(TargetResources.type)\n  | extend TargetId = tostring(TargetResources.id)\n  | project TimeGenerated, OperationName,  RoleName, Initiator, InitiatorId, Target, TargetId, TargetType, Result\n) on $left.TargetId == $right.InitiatorId\n| extend TimeRoleMgGrant = TimeGenerated, TimeAdminPromo = TimeGenerated1, ServicePrincipal = Initiator1, ServicePrincipalId = InitiatorId,\n  TargetObject = Target1, TargetObjectId = TargetId1, TargetObjectType = TargetType\n| where TimeRoleMgGrant < TimeAdminPromo\n| project TimeRoleMgGrant, TimeAdminPromo, RoleName, ServicePrincipal, ServicePrincipalId, TargetObject, TargetObjectId, TargetObjectType\n",
                "queryFrequency": "PT2H",
                "queryPeriod": "PT2H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "PrivilegeEscalation",
                  "Persistence"
                ],
                "techniques": [
                  "T1098",
                  "T1078"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/c38fda48-8405-4365-8f8c-3407c8d78206')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "(MDIoT) {{Description}}",
                  "alertDisplayNameFormat": "(MDIoT) {{AlertName}}",
                  "alertSeverityColumnName": "AlertSeverity",
                  "alertTacticsColumnName": "Tactics"
                },
                "alertRuleTemplateName": "f5217b4c-3f1f-4d89-b4f3-5d7581da1c1c",
                "customDetails": {
                  "AlertManagementUri": "AlertManagementUri",
                  "Protocol": "Protocol",
                  "VendorOriginalId": "VendorOriginalId",
                  "Sensor": "DeviceId"
                },
                "description": "This alert leverages Defender for IoT to detect excessive login attempts that may indicate improper service configuration, human error, or malicious activity on the network such as a cyber threat attempting to manipulate the SCADA network.",
                "displayName": "Excessive Login Attempts (Microsoft Defender for IoT)",
                "enabled": true,
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityAlert\n| where ProviderName == \"IoTSecurity\"\n| where AlertName in (\"Excessive Login Attempts\",\"Excessive SMB login attempts\",\"Password Guessing Attempt Detected\",\"Excessive Number of Sessions\") \n| extend ExtendedProperties = parse_json(ExtendedProperties)\n| where tostring(ExtendedProperties.isNew) == \"True\"\n| extend DeviceId = tostring(ExtendedProperties.DeviceId), \n         SourceDeviceAddress = tostring(ExtendedProperties.SourceDeviceAddress), \n         DestDeviceAddress = tostring(ExtendedProperties.DestinationDeviceAddress), \n         RemediationSteps = tostring(parse_json(RemediationSteps)[0]), \n         Protocol = tostring(ExtendedProperties.Protocol), \n         AlertManagementUri = tostring(ExtendedProperties.AlertManagementUri)\n| project\n  TimeGenerated,\n  DeviceId,\n  ProductName,\n  ProductComponentName,\n  AlertSeverity,\n  AlertName,\n  Description,\n  Protocol,\n  SourceDeviceAddress,\n  DestDeviceAddress,\n  RemediationSteps,\n  Tactics,\n  Entities,\n  VendorOriginalId,\n  AlertLink,\n  AlertManagementUri,\n  Techniques\n",
                "queryFrequency": "PT5M",
                "queryPeriod": "PT5M",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "ImpairProcessControl"
                ],
                "techniques": [
                  "T0806"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/d544292e-a784-476c-b010-929e4a4bfd78')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "fbd72eb8-087e-466b-bd54-1ca6ea08c6d3",
                "description": "Identifies if any tampering is done to either auditlog, ATP Safelink, SafeAttachment, AntiPhish or Dlp policy. \nAn adversary may use this technique to evade detection or avoid other policy based defenses.\nReferences: https://docs.microsoft.com/powershell/module/exchange/advanced-threat-protection/remove-antiphishrule?view=exchange-ps.",
                "displayName": "Office policy tampering",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let opList = OfficeActivity \n| summarize by Operation\n//| where Operation startswith \"Remove-\" or Operation startswith \"Disable-\"\n| where Operation has_any (\"Remove\", \"Disable\")\n| where Operation contains \"AntiPhish\" or Operation contains \"SafeAttachment\" or Operation contains \"SafeLinks\" or Operation contains \"Dlp\" or Operation contains \"Audit\"\n| summarize make_set(Operation);\nOfficeActivity\n// Only admin or global-admin can disable/remove policy\n| where RecordType =~ \"ExchangeAdmin\"\n| where UserType in~ (\"Admin\",\"DcAdmin\")\n// Pass in interesting Operation list\n| where Operation in~ (opList)\n| extend ClientIPOnly = case( \nClientIP has \".\", tostring(split(ClientIP,\":\")[0]), \nClientIP has \"[\", tostring(trim_start(@'[[]',tostring(split(ClientIP,\"]\")[0]))),\nClientIP\n)  \n| extend Port = case(\nClientIP has \".\", (split(ClientIP,\":\")[1]),\nClientIP has \"[\", tostring(split(ClientIP,\"]:\")[1]),\nClientIP\n)\n| summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), OperationCount = count() by Operation, UserType, UserId, ClientIP = ClientIPOnly, Port, ResultStatus, Parameters\n| extend timestamp = StartTimeUtc, AccountCustomEntity = UserId, IPCustomEntity = ClientIP\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence",
                  "DefenseEvasion"
                ],
                "techniques": [],
                "templateVersion": "2.0.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/22cd1d83-d573-45f4-9ced-edc0051a2a6f')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "83ba3057-9ea3-4759-bf6a-933f2e5bc7ee",
                "description": "This will alert when the \"Consent to application\" operation occurs by a user that has not done this operation before or rarely does this.\nThis could indicate that permissions to access the listed Azure App were provided to a malicious actor.\nConsent to application, Add service principal and Add OAuth2PermissionGrant should typically be rare events.\nThis may help detect the Oauth2 attack that can be initiated by this publicly available tool - https://github.com/fireeye/PwnAuth\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.",
                "displayName": "Rare application consent",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "CloudApplication",
                    "fieldMappings": [
                      {
                        "columnName": "TargetResourceName",
                        "identifier": "Name"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let current = 1d;\nlet auditLookback = 7d;\n// Setting threshold to 3 as a default, change as needed.\n// Any operation that has been initiated by a user or app more than 3 times in the past 7 days will be excluded\nlet threshold = 3;\n// Gather initial data from lookback period, excluding current, adjust current to more than a single day if no results\nlet AuditTrail = AuditLogs | where TimeGenerated >= ago(auditLookback) and TimeGenerated < ago(current)\n// 2 other operations that can be part of malicious activity in this situation are\n// \"Add OAuth2PermissionGrant\" and \"Add service principal\", extend the filter below to capture these too\n| where OperationName has \"Consent to application\"\n| extend InitiatedBy = iff(isnotempty(tostring(InitiatedBy.user.userPrincipalName)),\n          tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend TargetResourceName = tolower(tostring(TargetResource.displayName))\n  )\n| summarize max(TimeGenerated), OperationCount = count() by OperationName, InitiatedBy, TargetResourceName\n// only including operations initiated by a user or app that is above the threshold so we produce only rare and has not occurred in last 7 days\n| where OperationCount > threshold;\n// Gather current period of audit data\nlet RecentConsent = AuditLogs | where TimeGenerated >= ago(current)\n| where OperationName has \"Consent to application\"\n| extend IpAddress = case(\n              isnotempty(tostring(InitiatedBy.user.ipAddress)) and tostring(InitiatedBy.user.ipAddress) != 'null', tostring(InitiatedBy.user.ipAddress),\n              isnotempty(tostring(InitiatedBy.app.ipAddress)) and tostring(InitiatedBy.app.ipAddress) != 'null', tostring(InitiatedBy.app.ipAddress),\n              'Not Available')\n| extend InitiatedBy = iff(isnotempty(tostring(InitiatedBy.user.userPrincipalName)),\n                          tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"ServicePrincipal\"\n      | extend TargetResourceName = tolower(tostring(TargetResource.displayName)),\n               props = TargetResource.modifiedProperties\n  )\n| parse props with * \"ConsentType: \" ConsentType \"]\" *\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| project TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, UserAgent, CorrelationId, Type;\n// Exclude previously seen audit activity for \"Consent to application\" that was seen in the lookback period\n// First for rare InitiatedBy\nlet RareConsentBy = RecentConsent | join kind= leftanti AuditTrail on OperationName, InitiatedBy\n| extend Reason = \"Previously unseen user consenting\";\n// Second for rare TargetResourceName\nlet RareConsentApp = RecentConsent | join kind= leftanti AuditTrail on OperationName, TargetResourceName\n| extend Reason = \"Previously unseen app granted consent\";\nRareConsentBy | union RareConsentApp\n| summarize Reason = make_set(Reason,100) by TimeGenerated, InitiatedBy, IpAddress, TargetResourceName, Category, OperationName, ConsentType, UserAgent, CorrelationId, Type\n| extend timestamp = TimeGenerated, Name = tolower(tostring(split(InitiatedBy,'@',0)[0])), UPNSuffix = tolower(tostring(split(InitiatedBy,'@',1)[0]))\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P7D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence",
                  "PrivilegeEscalation"
                ],
                "techniques": [
                  "T1136",
                  "T1068"
                ],
                "templateVersion": "1.1.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 3
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/39742977-3409-4759-af53-9e7fee968857')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "The host at address {{SrcIpAddr}} sent an HTTP request to the URL {{Url}} with the HTTP user agent header {{HttpUserAgent}}. This user agent is known to be used by crypto miners and indicates crypto mining activity on the client.",
                  "alertDisplayNameFormat": "The host {{SrcIpAddr}} is potentially running a crypto miner"
                },
                "alertRuleTemplateName": "8cbc3215-fa58-4bd6-aaaa-f0029c351730",
                "customDetails": {
                  "UserAgent": "HttpUserAgent"
                },
                "description": "This rule identifies a web request with a user agent header known to belong to a crypto miner. This indicates a crypto miner may have infected the client machine.<br>You can add custom crypto mining indicating User-Agent headers using a watchlist, for more information refer to the [UnusualUserAgents Watchlist](https://aka.ms/ASimUnusualUserAgentsWatchlist).<br><br>   This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)",
                "displayName": "A host is potentially running a crypto miner (ASIM Web Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Url",
                        "identifier": "Url"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "SrcUsername",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threatCategory=\"Cryptominer\";\nlet knownUserAgentsIndicators = materialize(externaldata(UserAgent:string, Category:string)\n    [ @\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/UnusualUserAgents.csv\"] \n        with(format=\"csv\", ignoreFirstRecord=True));\nlet knownUserAgents=toscalar(knownUserAgentsIndicators | where Category==threatCategory | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet customUserAgents=toscalar(_GetWatchlist(\"UnusualUserAgents\") | where SearchKey==threatCategory | extend UserAgent=column_ifexists(\"UserAgent\",\"\") | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet fullUAList = array_concat(knownUserAgents,customUserAgents);\n_Im_WebSession(httpuseragent_has_any=fullUAList)\n| summarize N_Events=count() by  SrcIpAddr, Url, TimeGenerated,HttpUserAgent, SrcUsername",
                "queryFrequency": "PT15M",
                "queryPeriod": "PT15M",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CommandAndControl"
                ],
                "techniques": [],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/ff905e7e-ad2a-4567-a7ac-38228bb595e7')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "The host at address {{SrcIpAddr}} sent an HTTP request to the URL {{Url}} with the HTTP user agent header {{HttpUserAgent}}. This user agent is known to be used by PoerShell and indicates suspicious activity on the host.",
                  "alertDisplayNameFormat": "Host {{SrcIpAddr}} is potentially running PowerShell"
                },
                "alertRuleTemplateName": "42436753-9944-4d70-801c-daaa4d19ddd2",
                "customDetails": {
                  "UserAgent": "HttpUserAgent"
                },
                "description": "This rule identifies a web request with a user agent header known to belong PowerShell. <br>You can add custom Powershell indicating User-Agent headers using a watchlist, for more information refer to the [UnusualUserAgents Watchlist](https://aka.ms/ASimUnusualUserAgentsWatchlist).<br><br>\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)",
                "displayName": "A host is potentially running PowerShell to send HTTP(S) requests (ASIM Web Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Url",
                        "identifier": "Url"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "SrcUsername",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threatCategory=\"Powershell\";\nlet knownUserAgentsIndicators = materialize(externaldata(UserAgent:string, Category:string)\n    [ @\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/UnusualUserAgents.csv\"]\n        with(format=\"csv\", ignoreFirstRecord=True));\nlet knownUserAgents=toscalar(knownUserAgentsIndicators | where Category==threatCategory | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet customUserAgents=toscalar(_GetWatchlist(\"UnusualUserAgents\") | where SearchKey==threatCategory | extend UserAgent=column_ifexists(\"UserAgent\",\"\") | where isnotempty(UserAgent) | summarize make_list(UserAgent));\nlet fullUAList = array_concat(knownUserAgents,customUserAgents);\n_Im_WebSession(httpuseragent_has_any=fullUAList)\n| project SrcIpAddr, Url, TimeGenerated,HttpUserAgent, SrcUsername",
                "queryFrequency": "PT15M",
                "queryPeriod": "PT15M",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CommandAndControl",
                  "DefenseEvasion"
                ],
                "techniques": [],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b8fb163e-32fe-4689-b850-d083d8cfca30')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "A client with address {{SrcIpAddr}} communicated with host {{Name}} that have a domain name that might have been generated by a Domain Generation Algorithm (DGA), identified by the pattern {{DGADomain}}. DGAs are used by malware to generate rendezvous points that are difficult to predict in advance. This detection uses the top 1 million domain names to build a model of what normal domains look like and uses the model to identify domains that may have been randomly generated by an algorithm.",
                  "alertDisplayNameFormat": "Potential communication from {{SrcIpAddr} with a Domain Generation Algorithm (DGA) based host {{Name}}"
                },
                "alertRuleTemplateName": "9176b18f-a946-42c6-a2f6-0f6d17cd6a8a",
                "customDetails": {
                  "DGAPattern": "DGADomain",
                  "NameCount": "NameCount"
                },
                "description": "This rule identifies communication with hosts that have a domain name that might have been generated by a Domain Generation Algorithm (DGA). DGAs are used by malware to generate rendezvous points that are difficult to predict in advance. This detection uses the top 1 million domain names to build a model of what normal domains look like nad uses the model to identify domains that may have been randomly generated by an algorithm. You can modify the triThreshold and dgaLengthThreshold query parameters to change Analytic Rule sensitivity. The higher the numbers, the less noisy the rule is. <br>\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)",
                "displayName": "Potential communication with a Domain Generation Algorithm (DGA) based hostname (ASIM Web Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Url",
                        "identifier": "Url"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let triThreshold = 500;\nlet querystarttime = 6h;\nlet dgaLengthThreshold = 8;\n// fetch the cisco umbrella top 1M domains\nlet top1M =  (externaldata (Position:int, Domain:string)   [@\"http://s3-us-west-1.amazonaws.com/umbrella-static/top-1m.csv.zip\"]  with (format=\"csv\", zipPattern=\"*.csv\"));\n// extract tri grams that are above our threshold - i.e. are common\nlet triBaseline =   top1M\n  | extend Domain = tolower(extract(\"([^.]*).{0,7}$\", 1, Domain))\n  | extend AllTriGrams = array_concat(extract_all(\"(...)\", Domain), extract_all(\"(...)\", substring(Domain, 1)), extract_all(\"(...)\", substring(Domain, 2)))\n  | mvexpand Trigram=AllTriGrams to typeof(string)\n  | summarize triCount=count() by Trigram\n  | sort by triCount desc\n  | where triCount > triThreshold\n  | distinct Trigram;\n// collect domain information from common security log, filter and extract the DGA candidate and its trigrams\nlet allDataSummarized =  _Im_WebSession\n| where isnotempty(Url)\n| extend Name = tolower(tostring(parse_url(Url)[\"Host\"]))\n| summarize NameCount=count() by Name\n| where Name has \".\"\n| where Name !endswith \".home\" and Name !endswith \".lan\"\n// extract DGA candidate\n| extend DGADomain = extract(\"([^.]*).{0,7}$\", 1, Name)\n| where strlen(DGADomain) > dgaLengthThreshold\n// throw out domains with number in them\n| where DGADomain matches regex \"^[A-Za-z]{0,}$\"\n// extract the tri grams from summarized data\n| extend AllTriGrams = array_concat(extract_all(\"(...)\", DGADomain), extract_all(\"(...)\", substring(DGADomain, 1)), extract_all(\"(...)\", substring(DGADomain, 2)));\n// throw out domains that have repeating tri's and/or >=3 repeating letters\nlet nonRepeatingTris =  allDataSummarized\n| join kind=leftanti\n(\n    allDataSummarized\n    | mvexpand AllTriGrams\n    | summarize count() by tostring(AllTriGrams), DGADomain\n    | where count_ > 1\n    | distinct DGADomain\n)\non DGADomain;\n// find domains that do not have a common tri in the baseline\nlet dataWithRareTris =  nonRepeatingTris\n| join kind=leftanti\n(\n    nonRepeatingTris\n    | mvexpand AllTriGrams\n    | extend Trigram = tostring(AllTriGrams)\n    | distinct Trigram, DGADomain\n    | join kind=inner\n    (\n        triBaseline\n    )\n    on Trigram\n    | distinct DGADomain\n)\non DGADomain;\ndataWithRareTris\n// join DGAs back on connection data\n| join kind=inner\n(\n    _Im_WebSession\n    | where isnotempty(Url)\n    | extend Url = tolower(Url)\n    | summarize arg_max(TimeGenerated, EventVendor,  SrcIpAddr) by Url\n    | extend Name=tostring(parse_url(Url)[\"Host\"])\n    | summarize StartTime=min(TimeGenerated), EndTime=max(TimeGenerated) by Name, SrcIpAddr, Url\n)\non Name\n| project StartTime, EndTime, Name, DGADomain, SrcIpAddr, Url, NameCount",
                "queryFrequency": "PT6H",
                "queryPeriod": "PT6H",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CommandAndControl"
                ],
                "techniques": [
                  "T1568"
                ],
                "templateVersion": "1.1.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/88ce926a-d7c0-4eba-862d-01b6ee494e09')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "ef88eb96-861c-43a0-ab16-f3835a97c928",
                "description": "This query identifies use of PowerShell Empire's cmdlets within the command line data of the PowerShell process, indicating potential use of the post-exploitation tool.",
                "displayName": "Powershell Empire Cmdlets Executed in Command Line",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "SubjectUserName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "SubjectDomainName",
                        "identifier": "NTDomain"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostName",
                        "identifier": "HostName"
                      },
                      {
                        "columnName": "DnsDomain",
                        "identifier": "DnsDomain"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let regexEmpire = tostring(toscalar(externaldata(cmdlets:string)[@\"https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/Sample%20Data/Feeds/EmpireCommandString.txt\"] with (format=\"txt\")));\n(union isfuzzy=true\n (SecurityEvent\n| where EventID == 4688\n//consider filtering on filename if perf issues occur\n//where FileName in~ (\"powershell.exe\",\"powershell_ise.exe\",\"pwsh.exe\")\n| where not(ParentProcessName has_any ('gc_worker.exe', 'gc_service.exe'))\n| where CommandLine has \"-encodedCommand\"\n| parse kind=regex flags=i CommandLine with * \"-EncodedCommand \" encodedCommand\n| extend encodedCommand = iff(encodedCommand has \" \", tostring(split(encodedCommand, \" \")[0]), encodedCommand)\n// Note: currently the base64_decode_tostring function is limited to supporting UTF8\n| extend decodedCommand = translate('\\0','', base64_decode_tostring(substring(encodedCommand, 0, strlen(encodedCommand) -  (strlen(encodedCommand) %8)))), encodedCommand, CommandLine , strlen(encodedCommand)\n| extend EfectiveCommand = iff(isnotempty(encodedCommand), decodedCommand, CommandLine)\n| where EfectiveCommand matches regex regexEmpire\n| project timestamp = TimeGenerated, Computer, SubjectUserName, SubjectDomainName, FileName = Process, EfectiveCommand, decodedCommand, encodedCommand, CommandLine, ParentProcessName\n| extend HostName = split(Computer, '.', 0)[0], DnsDomain = strcat_array(array_slice(split(Computer, '.'), 1, -1), '.')\n),\n(WindowsEvent\n| where EventID == 4688\n| where EventData has_any (\"-encodedCommand\", \"powershell.exe\",\"powershell_ise.exe\",\"pwsh.exe\")\n| where not(EventData has_any ('gc_worker.exe', 'gc_service.exe'))\n//consider filtering on filename if perf issues occur\n//extend NewProcessName = tostring(EventData.NewProcessName)\n//extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n//FileName = Process\n//where FileName in~ (\"powershell.exe\",\"powershell_ise.exe\",\"pwsh.exe\")\n| extend ParentProcessName = tostring(EventData.ParentProcessName)\n| where not(ParentProcessName has_any ('gc_worker.exe', 'gc_service.exe'))\n| extend CommandLine = tostring(EventData.CommandLine)\n| where CommandLine has \"-encodedCommand\"\n| parse kind=regex flags=i CommandLine with * \"-EncodedCommand \" encodedCommand\n| extend encodedCommand = iff(encodedCommand has \" \", tostring(split(encodedCommand, \" \")[0]), encodedCommand)\n// Note: currently the base64_decode_tostring function is limited to supporting UTF8\n| extend decodedCommand = translate('\\0','', base64_decode_tostring(substring(encodedCommand, 0, strlen(encodedCommand) -  (strlen(encodedCommand) %8)))), encodedCommand, CommandLine , strlen(encodedCommand)\n| extend EfectiveCommand = iff(isnotempty(encodedCommand), decodedCommand, CommandLine)\n| where EfectiveCommand matches regex regexEmpire\n| extend SubjectUserName = tostring(EventData.SubjectUserName)\n| extend SubjectDomainName = tostring(EventData.SubjectDomainName)\n| extend NewProcessName = tostring(EventData.NewProcessName)\n| extend Process=tostring(split(NewProcessName, '\\\\')[-1])\n| project timestamp = TimeGenerated, Computer, SubjectUserName, SubjectDomainName, FileName = Process, EfectiveCommand, decodedCommand, encodedCommand, CommandLine, ParentProcessName\n| extend HostName = split(Computer, '.', 0)[0], DnsDomain = strcat_array(array_slice(split(Computer, '.'), 1, -1), '.')\n))\n",
                "queryFrequency": "PT12H",
                "queryPeriod": "PT12H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Collection",
                  "CommandAndControl",
                  "CredentialAccess",
                  "DefenseEvasion",
                  "Discovery",
                  "Execution",
                  "Exfiltration",
                  "LateralMovement",
                  "Persistence",
                  "PrivilegeEscalation"
                ],
                "techniques": [
                  "T1548",
                  "T1134",
                  "T1134",
                  "T1134",
                  "T1087",
                  "T1087",
                  "T1557",
                  "T1071",
                  "T1560",
                  "T1547",
                  "T1547",
                  "T1547",
                  "T1217",
                  "T1115",
                  "T1059",
                  "T1059",
                  "T1059",
                  "T1136",
                  "T1136",
                  "T1543",
                  "T1555",
                  "T1484",
                  "T1482",
                  "T1114",
                  "T1573",
                  "T1546",
                  "T1041",
                  "T1567",
                  "T1567",
                  "T1068",
                  "T1210",
                  "T1083",
                  "T1615",
                  "T1574",
                  "T1574",
                  "T1574",
                  "T1574",
                  "T1574",
                  "T1070",
                  "T1105",
                  "T1056",
                  "T1056",
                  "T1106",
                  "T1046",
                  "T1135",
                  "T1040",
                  "T1027",
                  "T1003",
                  "T1057",
                  "T1055",
                  "T1021",
                  "T1021",
                  "T1053",
                  "T1113",
                  "T1518",
                  "T1558",
                  "T1558",
                  "T1082",
                  "T1016",
                  "T1049",
                  "T1569",
                  "T1127",
                  "T1552",
                  "T1552",
                  "T1550",
                  "T1125",
                  "T1102",
                  "T1047"
                ],
                "templateVersion": "1.3.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/5b10ffb5-cf3e-47d9-9a6b-f5680802b83a')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "c3b11fb2-9201-4844-b7b9-6b7bf6d9b851",
                "description": "This creates an incident in the event a client generates excessive amounts of DNS queries for non-existent domains. \nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema",
                "displayName": "Excessive NXDOMAIN DNS Queries (ASIM DNS Schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threshold = 200;\n_Im_Dns(responsecodename='NXDOMAIN')\n| where isnotempty(DnsResponseCodeName)\n//| where DnsResponseCodeName =~ \"NXDOMAIN\"\n| summarize count() by SrcIpAddr, bin(TimeGenerated,15m)\n| where count_ > threshold\n| join kind=inner (_Im_Dns(responsecodename='NXDOMAIN')\n    ) on SrcIpAddr\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcIpAddr",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CommandAndControl"
                ],
                "techniques": [
                  "T1568",
                  "T1008"
                ],
                "templateVersion": "1.3.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/13f58f8b-6f64-4c35-a99c-5bec8553b8c9')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "4ebbb5c2-8802-11ec-a8a3-0242ac120002",
                "description": "This query detects the installation of a Windows service that contains artifacts from credential dumping tools such as Mimikatz.",
                "displayName": "Credential Dumping Tools - Service Installation",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountName",
                        "identifier": "Name"
                      }
                    ]
                  },
                  {
                    "entityType": "File",
                    "fieldMappings": [
                      {
                        "columnName": "ImagePath",
                        "identifier": "Name"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostName",
                        "identifier": "HostName"
                      },
                      {
                        "columnName": "DnsDomain",
                        "identifier": "DnsDomain"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "// Enter a reference list of decoy users (usernames) \"Case Sensitive\"\nlet MaliciousServiceArtifacts = dynamic ([\"fgexec\",\"cachedump\",\"mimikatz\",\"mimidrv\",\"wceservice\",\"pwdump\"]);\nEvent\n| where Source == \"Service Control Manager\" and EventID == 7045\n| parse EventData with * 'ServiceName\">' ServiceName \"<\" * 'ImagePath\">' ImagePath \"<\" *\n| where ServiceName has_any (MaliciousServiceArtifacts) or ImagePath has_any (MaliciousServiceArtifacts)\n| parse EventData with * 'AccountName\">' AccountName \"<\" *\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated) by EventID, Computer, ServiceName, ImagePath, AccountName\n| extend HostName = split(Computer, '.', 0)[0], DnsDomain = strcat_array(array_slice(split(Computer, '.'), 1, -1), '.')\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1003"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/cdb3d1dc-55a4-4411-8f38-0873ee880ab3')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "218f60de-c269-457a-b882-9966632b9dc6",
                "customDetails": {
                  "InitiatedByUser": "InitiatedByUser",
                  "TargetUser": "Target"
                },
                "description": "Identifies when changes to multiple users permissions are changed at once. Investigate immediately if not a planned change. This setting could enable an attacker access to Azure subscriptions in your environment.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-identity-management",
                "displayName": "Bulk Changes to Privileged Account Permissions",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "TargetName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "TargetUPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatedByUserName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "InitiatedByUserUPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let AdminRecords = AuditLogs\n| where Category =~ \"RoleManagement\"\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-apply TargetResource = TargetResources on \n  (\n      where TargetResource.type =~ \"User\"\n      | extend Target = tostring(TargetResource.userPrincipalName),\n               props = TargetResource.modifiedProperties\n  )\n| mv-apply Property = props on \n  (\n      where Property.displayName =~ \"Role.DisplayName\"\n      | extend RoleName = trim('\"',tostring(Property.newValue))\n  )\n| where RoleName contains \"Admin\";\nAdminRecords\n| summarize dcount(Target) by bin(TimeGenerated, 1h)\n| where dcount_Target > 9\n| join kind=rightsemi  (\n  AdminRecords\n  | extend TimeWindow = bin(TimeGenerated, 1h)\n) on $left.TimeGenerated == $right.TimeWindow\n| extend InitiatedByUser = iff(isnotempty(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.user.userPrincipalName), \"\")\n| extend TargetName = tostring(split(Target,'@',0)[0]), TargetUPNSuffix = tostring(split(Target,'@',1)[0]),\n         InitiatedByUserName = tostring(split(InitiatedByUser,'@',0)[0]), InitiatedByUserUPNSuffix = tostring(split(InitiatedByUser,'@',1)[0])",
                "queryFrequency": "PT2H",
                "queryPeriod": "PT2H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "PrivilegeEscalation"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.0.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/a9cf5faa-96c4-4116-9956-b82b22ba8f49')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "This query looks for successful sign in attempts to the Azure Portal where the user who is signing in from another Azure tenant,\nand the IP address the login attempt is from is an Azure IP. A threat actor who compromises an Azure tenant may look\nto pivot to other tenants leveraging cross-tenant delegated access in this manner.\nIn this instance {{UserPrincipalName}} logged in at {{FirstSeen}} from IP Address {{IPAddress}}.\n",
                  "alertDisplayNameFormat": "Azure Portal sign in by {{UserPrincipalName}} from another Azure Tenant with IP Address {{IPAddress}}"
                },
                "alertRuleTemplateName": "87210ca1-49a4-4a7d-bb4a-4988752f978c",
                "description": "This query looks for successful sign in attempts to the Azure Portal where the user who is signing in from another Azure tenant,\n and the IP address the login attempt is from is an Azure IP. A threat actor who compromises an Azure tenant may look\n to pivot to other tenants leveraging cross-tenant delegated access in this manner.",
                "displayName": "Azure Portal sign in from another Azure Tenant",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      },
                      {
                        "columnName": "UserId",
                        "identifier": "AadUserId"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "// Get details of current Azure Ranges (note this URL updates regularly so will need to be manually updated over time)\n// You may find the name of the new JSON here: https://www.microsoft.com/download/details.aspx?id=56519\n// On the downloads page, click the 'details' button, and then replace just the filename in the URL below\nlet azure_ranges = externaldata(changeNumber: string, cloud: string, values: dynamic)\n[\"https://raw.githubusercontent.com/microsoft/mstic/master/PublicFeeds/MSFTIPRanges/ServiceTags_Public.json\"] with(format='multijson')\n| mv-expand values\n| mv-expand values.properties.addressPrefixes\n| mv-expand values_properties_addressPrefixes\n| summarize by tostring(values_properties_addressPrefixes)\n| extend isipv4 = parse_ipv4(values_properties_addressPrefixes)\n| extend isipv6 = parse_ipv6(values_properties_addressPrefixes)\n| extend ip_type = case(isnotnull(isipv4), \"v4\", \"v6\")\n| summarize make_list(values_properties_addressPrefixes) by ip_type\n;\nSigninLogs\n// Limiting to Azure Portal really reduces false positives and helps focus on potential admin activity\n| where ResultType == 0\n| where AppDisplayName =~ \"Azure Portal\"\n| extend isipv4 = parse_ipv4(IPAddress)\n| extend ip_type = case(isnotnull(isipv4), \"v4\", \"v6\")\n // Only get logons where the IP address is in an Azure range\n| join kind=fullouter (azure_ranges) on ip_type\n| extend ipv6_match = ipv6_is_in_any_range(IPAddress,  list_values_properties_addressPrefixes)\n| extend ipv4_match = ipv4_is_in_any_range(IPAddress,  list_values_properties_addressPrefixes)\n| where ipv4_match or ipv6_match \n// Limit to where the user is external to the tenant\n| where HomeTenantId != ResourceTenantId\n// Further limit it to just access to the current tenant (you can drop this if you wanted to look elsewhere as well but it helps reduce FPs)\n| where ResourceTenantId == AADTenantId\n| summarize FirstSeen = min(TimeGenerated), LastSeen = max(TimeGenerated), make_set(ResourceDisplayName) by UserPrincipalName, IPAddress, UserAgent, Location, HomeTenantId, ResourceTenantId, UserId\n| extend AccountName = split(UserPrincipalName, \"@\")[0]\n| extend UPNSuffix = split(UserPrincipalName, \"@\")[1]",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1199"
                ],
                "templateVersion": "2.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/4a50c986-ce8d-4d84-a7de-6a9b9904d5d0')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "A client with address {{SrcIpAddr}} requested the URL {{Url}}, whose hostname is a known indicator of compromise of {{ThreatType}}. Consult the threat intelligence blead for more information on the indicator.",
                  "alertDisplayNameFormat": "A web request from {{SrcIpAddr}} to hostname  {{domain}} matched an IoC"
                },
                "alertRuleTemplateName": "b1832f60-6c3d-4722-a0a5-3d564ee61a63",
                "customDetails": {
                  "EventTime": "Event_TimeGenerated",
                  "ActivityGroupNames": "ActivityGroupNames",
                  "IoCConfidenceScore": "ConfidenceScore",
                  "IoCExpirationTime": "ExpirationDateTime",
                  "IndicatorId": "IndicatorId",
                  "IoCDescription": "Description",
                  "ThreatType": "ThreatType"
                },
                "description": "This rule identifies Web Sessions for which the target URL hostname is a known IoC. <br><br>This rule uses the [Advanced Security Information Model (ASIM)](https:/aka.ms/AboutASIM) and supports any web session source that complies with ASIM.",
                "displayName": "(Preview) TI map Domain entity to Web Session Events (ASIM Web Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Url",
                        "identifier": "Url"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let HAS_ANY_MAX = 10000;\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\n//Create a list of TLDs in our threat feed for later validation\nlet DOMAIN_TI=ThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// Picking up only IOC's that contain the entities we want\n| where isnotempty(DomainName);\nlet DOMAIN_TI_list= todynamic(toscalar(DOMAIN_TI | summarize NIoCs = dcount(DomainName), Domains = make_set(DomainName) \n  | project Domains=iff(NIoCs > HAS_ANY_MAX, dynamic([]), Domains) ));\nDOMAIN_TI\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    _Im_WebSession(starttime=ago(dt_lookBack), url_has_any= DOMAIN_TI_list )\n    //Extract domain patterns from syslog message\n    | extend domain = tostring(parse_url(Url)[\"Host\"])\n    | where isnotempty(domain)\n    | extend tld = tostring(split(domain, '.')[-1])\n    | extend Event_TimeGenerated = TimeGenerated\n) on $left.DomainName==$right.domain\n| where Event_TimeGenerated < ExpirationDateTime\n| summarize Event_TimeGenerated  = arg_max(Event_TimeGenerated , *) by IndicatorId, domain\n| project Event_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, domain, SrcIpAddr, Url   \n",
                "queryFrequency": "PT1H",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/41773aaa-29a6-479f-892c-da8e48455b99')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "738702fd-0a66-42c7-8586-e30f0583f8fe",
                "description": "Identifies SolarWinds TEARDROP memory-only dropper IOCs in Window's defender Exploit Guard activity\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f",
                "displayName": "TEARDROP memory-only dropper",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountEntity",
                        "identifier": "Name"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostName",
                        "identifier": "HostName"
                      },
                      {
                        "columnName": "DnsDomain",
                        "identifier": "DnsDomain"
                      }
                    ]
                  },
                  {
                    "entityType": "FileHash",
                    "fieldMappings": [
                      {
                        "columnName": "FileHashType",
                        "identifier": "Algorithm"
                      },
                      {
                        "columnName": "InitiatingProcessSHA1",
                        "identifier": "Value"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "DeviceEvents\n| where ActionType has \"ExploitGuardNonMicrosoftSignedBlocked\"\n| where InitiatingProcessFileName has \"svchost.exe\" and FileName has \"NetSetupSvc.dll\"\n| extend timestamp = TimeGenerated, AccountEntity = iff(isnotempty(InitiatingProcessAccountUpn), InitiatingProcessAccountUpn, InitiatingProcessAccountName),FileHashType = \"SHA1\"\n| extend HostName = tostring(split(DeviceName, '.', 0)[0]), DnsDomain = tostring(strcat_array(array_slice(split(DeviceName, '.'), 1, -1), '.'))\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution",
                  "Persistence",
                  "DefenseEvasion"
                ],
                "techniques": [
                  "T1543",
                  "T1059",
                  "T1027"
                ],
                "templateVersion": "1.0.5",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/bdf26b6f-5671-4120-a769-fdf4276d453d')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "b9d2eebc-5dcb-4888-8165-900db44443ab",
                "description": "This query detects potential attempts by non-computer accounts (non domain controllers) to retrieve/synchronize an active directory object leveraging directory replication services (DRS).\nA Domain Controller (computer account) would usually be performing these actions in a domain environment. Another detection rule can be created to cover domain controllers accounts doing at rare times.\nA domain user with privileged permissions to use directory replication services is rare. Ref: https://threathunterplaybook.com/notebooks/windows/06_credential_access/WIN-180815210510.html'",
                "displayName": "Non Domain Controller Active Directory Replication",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SourceAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "// Enter a reference list of hostnames for your DC servers\n//let DCServersList = dynamic ([\"DC01.simulandlabs.com\",\"DC02.simulandlabs.com\"]);\nSecurityEvent\n//| where Computer in (DCServersList)\n| where EventID == 4662 and ObjectServer == 'DS'\n| where AccountType != 'Machine'\n| where Properties has '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2' //DS-Replication-Get-Changes\n    or Properties has '1131f6ad-9c07-11d1-f79f-00c04fc2dcd2' //DS-Replication-Get-Changes-All\n    or Properties has '89e95b76-444d-4c62-991a-0facbeda640c' //DS-Replication-Get-Changes-In-Filtered-Set\n| project TimeGenerated, Account, Activity, Properties, SubjectLogonId, Computer\n| join kind=leftouter\n(\n    SecurityEvent\n    //| where Computer in (DCServersList)\n    | where EventID == 4624 and LogonType == 3\n    | where AccountType != 'Machine'\n    | project TargetLogonId, IpAddress\n)\non $left.SubjectLogonId == $right.TargetLogonId\n| project-reorder TimeGenerated, Computer, Account, IpAddress\n| extend timestamp = TimeGenerated, AccountCustomEntity = Account, HostCustomEntity = Computer, SourceAddress = IpAddress \n",
                "queryFrequency": "P1D",
                "queryPeriod": "P7D",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/1088ac2e-3910-4b44-be05-f808f9aa1a4c')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "011c84d8-85f0-4370-b864-24c13455aa94",
                "description": "The query identifies any efforts by an attacker to delete backup containers, while also searching for any security alerts that may be linked to the same activity, in order to uncover additional information about the attacker's actions.' \nThough such an activity could be legitimate as part of business operation, some ransomware actors may perform such operation to cause interruption to regular business services.",
                "displayName": "Detect CoreBackUp Deletion Activity from related Security Alerts",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "UserName",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "NTDomain",
                        "identifier": "NTDomain"
                      }
                    ]
                  },
                  {
                    "entityType": "AzureResource",
                    "fieldMappings": [
                      {
                        "columnName": "_ResourceId",
                        "identifier": "ResourceId"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostName",
                        "identifier": "HostName"
                      },
                      {
                        "columnName": "DnsDomain",
                        "identifier": "DnsDomain"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "SecurityAlert\n| extend Extprop = parse_json(ExtendedProperties)\n| mv-expand todynamic(Entities)\n| extend HostName = iff(isnotempty(tostring(Extprop[\"Compromised Host\"])), tolower(tostring(Extprop[\"Compromised Host\"])), tolower(tostring(parse_json(Entities).HostName)))\n| where isnotempty(HostName)\n| mv-expand todynamic(split(HostName, ','))\n| extend DnsDomain = iff(isnotempty(tostring(Extprop[\"Machine Domain\"])), tostring(Extprop[\"Machine Domain\"]), tostring(parse_json(Entities).DnsDomain))\n| extend UserName = iff(isnotempty(tostring(Extprop[\"User Name\"])), tostring(Extprop[\"User Name\"]), iff(tostring(parse_json(Entities).Type) == 'account', tostring(parse_json(Entities).Name), ''))\n| extend NTDomain = iff(isnotempty(tostring(Extprop[\"User Domain\"])), tostring(Extprop[\"User Domain\"]), tostring(parse_json(Entities).NTDomain))\n| extend IpAddress = iff(tostring(parse_json(Entities).Type) == 'ip', tostring(parse_json(Entities).Address), tostring(parse_json(Extprop).[\"IpAddress\"]))\n| summarize timestamp = arg_max(TimeGenerated, *) by AlertName, tostring(HostName)\n| project timestamp, AlertName, UserName, NTDomain, tostring(HostName), DnsDomain, IpAddress\n| join kind=inner\n(\nCoreAzureBackup\n| where State =~ \"Deleted\"\n| where OperationName =~ \"BackupItem\"\n| extend data = split(BackupItemUniqueId, \";\")\n| extend AzureLocation = data[0], VaultId=data[1], HostName=tolower(tostring(data[2])), DrivesBackedUp=data[3]\n| project timestamp = TimeGenerated, AzureLocation, VaultId, HostName, DrivesBackedUp, State, BackupItemUniqueId, _ResourceId, OperationName, BackupItemFriendlyName\n)\non HostName\n| project timestamp, AlertName, HostName, DnsDomain, UserName, NTDomain, _ResourceId, IpAddress, VaultId, AzureLocation, DrivesBackedUp, State, BackupItemUniqueId, OperationName, BackupItemFriendlyName",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [
                  "T1496"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/ba72a490-8a49-4667-89e9-b75ddd87e838')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "28a75d10-9b75-4192-9863-e452c3ad24db",
                "description": "This alert joins SecurityAlerts to SecurityIncidents to associate Security Alerts and Incidents with user accounts. This aligns all Microsoft Alerting Products with Microsoft Incident Generating Products (Microsoft Sentinel, M365 Defender) for a count of user security incidents over time. The default threshold is 5 security incidents, and this is customizable per the organization's requirements. Results include UserPrincipalName (UPN), SecurityIncident, LastIncident, ProductName, LastObservedTime, and Previous Incidents. There is an option for configuration of correlations against Microsoft Sentinel watchlists. For more information, see [Investigate incidents with Microsoft Sentinel]( https://docs.microsoft.com/azure/sentinel/investigate-cases).",
                "displayName": "Insider Risk_High User Security Incidents Correlation",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "AadUserId"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let PreviousIncidents =\nSecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize PreviousIncidents = make_set(IncidentNumber) by UPN;\nlet LastTimeObserved =\nSecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize arg_max(TimeGenerated, IncidentName) by UPN;\n  SecurityIncident\n| summarize hint.strategy = shuffle arg_max(LastModifiedTime, *) by IncidentNumber\n| mv-expand AlertIds\n| extend AlertId = tostring(AlertIds)\n| join kind= innerunique ( \n          SecurityAlert \n          )\n          on $left.AlertId == $right.SystemAlertId\n| summarize hint.strategy = shuffle arg_max(TimeGenerated, *), NumberOfUpdates = count() by SystemAlertId\n| mv-expand todynamic(Entities)\n| where Entities[\"Type\"] =~ \"account\"\n| extend Name = tostring(tolower(Entities[\"Name\"])), NTDomain = tostring(Entities[\"NTDomain\"]), UPNSuffix = tostring(Entities[\"UPNSuffix\"]), AadUserId = tostring(Entities[\"AadUserId\"]), AadTenantId = tostring(Entities[\"AadTenantId\"]), \n          Sid = tostring(Entities[\"Sid\"]), IsDomainJoined = tobool(Entities[\"IsDomainJoined\"]), Host = tostring(Entities[\"Host\"])\n| extend UPN = iff(Name != \"\" and UPNSuffix != \"\", strcat(Name, \"@\", UPNSuffix), \"\")\n| extend Href_ = tostring(parse_json(ExtendedLinks)[0].Href)\n| where UPN <> \"\"\n| summarize count() by UPN, IncidentName, IncidentNumber, IncidentUrl, Severity, ProductName\n| extend SecurityIncidents = count_\n| where SecurityIncidents > 5 //Adjust & Tune within Organzational Requirements\n| join (LastTimeObserved) on UPN\n| project-rename LastObserved = TimeGenerated, LastIncident = IncidentNumber\n| project-away IncidentName, count_, UPN1, IncidentName1, Severity, IncidentUrl\n| join kind=inner (PreviousIncidents) on UPN\n// | lookup kind=inner _GetWatchlist('<Your Watchlist Name>') on $left.UPN == $right.SearchKey\n| project UPN, SecurityIncidents, LastIncident, ProductName, LastObserved, PreviousIncidents\n| sort by SecurityIncidents desc\n| limit 25\n| extend AccountCustomEntity = UPN\n",
                "queryFrequency": "P7D",
                "queryPeriod": "P7D",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution"
                ],
                "techniques": [],
                "templateVersion": "1.1.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/883f6ac0-5d4e-48d8-87f2-ffb3bd3bfcbb')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "999e9f5d-db4a-4b07-a206-29c4e667b7e8",
                "customDetails": {
                  "Description": "Description",
                  "ActivityGroupNames": "ActivityGroupNames",
                  "IndicatorId": "IndicatorId",
                  "ThreatType": "ThreatType",
                  "LatestIndicatorTime": "LatestIndicatorTime",
                  "ExpirationDateTime": "ExpirationDateTime",
                  "SourceIPAddress": "SrcIpAddr",
                  "ConfidenceScore": "ConfidenceScore",
                  "DNSRequestTime": "DNS_TimeGenerated",
                  "DnsQuery": "DnsQuery",
                  "QueryType": "DnsQueryType"
                },
                "description": "Identifies a match in DNS events from any Domain IOC from TI\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema'",
                "displayName": "(Preview) TI map Domain entity to Dns Events (ASIM DNS Schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "URLCustomEntity",
                        "identifier": "Url"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let HAS_ANY_MAX = 10000;\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet DomainTIs= ThreatIntelligenceIndicator\n  | where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n  // Picking up only IOC's that contain the entities we want\n  | where isnotempty(DomainName)\n  | where Active == true\n  | summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId;\nlet Domains = DomainTIs | where isnotempty(DomainName) |summarize NDomains=dcount(DomainName), DomainsList=make_set(DomainName) \n  | project DomainList = iff(NDomains > HAS_ANY_MAX, dynamic([]), DomainsList) ;\nDomainTIs\n  | join (\n      _Im_Dns(starttime=ago(dt_lookBack), domain_has_any=toscalar(Domains))\n      | extend DNS_TimeGenerated = TimeGenerated\n) on $left.DomainName==$right.DnsQuery\n| where DNS_TimeGenerated < ExpirationDateTime\n| project LatestIndicatorTime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, Url, DNS_TimeGenerated, Dvc, SrcIpAddr, DnsQuery, DnsQueryType\n| extend timestamp = DNS_TimeGenerated, HostCustomEntity = Dvc, IPCustomEntity = SrcIpAddr, URLCustomEntity = Url\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [],
                "templateVersion": "1.1.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/60fed49c-34cb-4272-9606-e21615ad5e86')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "f8b3c49c-4087-499b-920f-0dcfaff0cbca",
                "description": "Identifies instances of a base64 encoded PE file header seen in the process command line parameter.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)",
                "displayName": "Base64 encoded Windows process command-lines (Normalized Process Events)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "imProcessCreate\n  | where CommandLine contains \"TVqQAAMAAAAEAAA\"\n  | where isnotempty(Process)\n  | summarize StartTimeUtc = min(TimeGenerated), EndTimeUtc = max(TimeGenerated), count() by Dvc, ActorUsername, Process, CommandLine, ActingProcessName, EventVendor, EventProduct\n  | extend timestamp = StartTimeUtc, AccountCustomEntity = ActorUsername, HostCustomEntity = Dvc",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution",
                  "DefenseEvasion"
                ],
                "techniques": [
                  "T1059",
                  "T1027",
                  "T1140"
                ],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/8eee3d7e-24d5-46f7-aace-5931f3193220')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "The response address {{IoC}} to a DNS query matched a known indicator of compromise of {{ThreatType}}. Consult the threat intelligence blade for more information on the indicator.",
                  "alertDisplayNameFormat": "The response {{IoC}} to DNS query matched an IoC"
                },
                "alertRuleTemplateName": "67775878-7f8b-4380-ac54-115e1e828901",
                "customDetails": {
                  "ActivityGroupNames": "ActivityGroupNames",
                  "IndicatorId": "IndicatorId",
                  "ThreatType": "ThreatType",
                  "Description": "Description",
                  "LatestIndicatorTime": "LatestIndicatorTime",
                  "ExpirationDateTime": "ExpirationDateTime",
                  "ConfidenceScore": "ConfidenceScore",
                  "SourceIPAddress": "SrcIpAddr",
                  "DNSRequestTime": "imDns_mintime",
                  "DnsQuery": "DnsQuery"
                },
                "description": "This rule identifies DNS requests for which response IP address is a known IoC. <br><br>\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM DNS schema.",
                "displayName": "(Preview) TI map IP entity to DNS Events (ASIM DNS schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "Dvc",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IoC",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet IP_TI = \nThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n| extend IoC = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,\"NO_IP\")\n| where IoC != \"NO_IP\"\n;\nIP_TI\n| join kind=innerunique // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n(\n_Im_Dns(starttime=ago(dt_lookBack))\n| where isnotempty(DnsResponseName)\n| summarize imDns_mintime=min(TimeGenerated), imDns_maxtime=max(TimeGenerated) by SrcIpAddr, DnsQuery, DnsResponseName, Dvc, EventProduct, EventVendor\n| extend addresses = extract_all (@'(\\d+\\.\\d+\\.\\d+\\.\\d+)', DnsResponseName)\n| mv-expand IoC = addresses to typeof(string)\n)\non IoC\n| where imDns_mintime < ExpirationDateTime\n| project imDns_mintime, imDns_maxtime, Description, ActivityGroupNames, IndicatorId, ThreatType, LatestIndicatorTime, ExpirationDateTime, ConfidenceScore, SrcIpAddr, IoC, Dvc, EventVendor, EventProduct, DnsQuery, DnsResponseName\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [],
                "templateVersion": "1.2.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b8fe75a9-aa06-46b6-965f-a02926cf7860')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "A port scan has been performed from address {{SrcIpAddr}} over {{AttemptedPortsCount}} ports within 5 minutes. This may indicate that a [port scanner](https://en.wikipedia.org/wiki/Port_scanner) is trying to identify open ports in order to penetrate a system.",
                  "alertDisplayNameFormat": "Potential port scan from {{SrcIpAddr}}"
                },
                "alertRuleTemplateName": "1da9853f-3dea-4ea9-b7e5-26730da3d537",
                "customDetails": {
                  "AttemptedPortsCount": "AttemptedPortsCount"
                },
                "description": "This rule identifies a possible port scan, in which a single source tries to access a large number of different ports is a short time frame. This may indicate that a [port scanner](https://en.wikipedia.org/wiki/Port_scanner) is trying to identify open ports in order to penetrate a system.<br><br>\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema",
                "displayName": "Port scan detected  (ASIM Network Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let PortScanThreshold = 50;\n_Im_NetworkSession\n| where ipv4_is_private(SrcIpAddr) == False\n| where SrcIpAddr !in (\"127.0.0.1\", \"::1\")\n| summarize AttemptedPortsCount=dcount(DstPortNumber), AttemptedPorts=make_set(DstPortNumber, 100), ReportedBy=make_set(strcat(EventVendor, \"/\", EventProduct), 20) by SrcIpAddr, bin(TimeGenerated, 5m)\n| where AttemptedPortsCount > PortScanThreshold",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Discovery"
                ],
                "techniques": [
                  "T1046"
                ],
                "templateVersion": "1.0.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/52449fda-5e70-460b-94c0-c3a812b22cd6')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "29a29e5d-354e-4f5e-8321-8b39d25047bf",
                "description": "This hunting query looks for file paths/hashes related to observed activity by Dev-0228. The actor is known to use custom version of popular tool like PsExec, Procdump etc. to carry its activity.\n The risk score associated with each result is based on a number of factors, hosts with higher risk events should be investigated first.\n This query uses the Microsoft Sentinel Information Model - https://docs.microsoft.com/azure/sentinel/normalization",
                "displayName": "Dev-0228 File Path Hashes November 2021 (ASIM Version)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "HostName"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "Name"
                      }
                    ]
                  },
                  {
                    "entityType": "File",
                    "fieldMappings": [
                      {
                        "columnName": "OriginalFileName",
                        "identifier": "Name"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let files1 = dynamic([\"C:\\\\Windows\\\\TAPI\\\\lsa.exe\", \"C:\\\\Windows\\\\TAPI\\\\pa.exe\", \"C:\\\\Windows\\\\TAPI\\\\pc.exe\", \"C:\\\\Windows\\\\TAPI\\\\Rar.exe\"]);\n let files2 = dynamic([\"svchost.exe\",\"wdmsvc.exe\"]);\n let FileHash1 = dynamic([\"43109fbe8b752f7a9076eaafa417d9ae5c6e827cd5374b866672263fdebd5ec3\", \"ab50d8d707b97712178a92bbac74ccc2a5699eb41c17aa77f713ff3e568dcedb\", \"010e32be0f86545e116a8bc3381a8428933eb8789f32c261c81fd5e7857d4a77\",     \"56cd102b9fc7f3523dad01d632525ff673259dbc9a091be0feff333c931574f7\"]);\n let FileHash2 = dynamic([\"2a1044e9e6e87a032f80c6d9ea6ae61bbbb053c0a21b186ecb3b812b49eb03b7\", \"9ab7e99ed84f94a7b6409b87e56dc6e1143b05034a5e4455e8c555dbbcd0d2dd\", \"18a072ccfab239e140d8f682e2874e8ff19d94311fc8bb9564043d3e0deda54b\"]);\n imProcessCreate\n | where ((Process has_any (files1)) and (ActingProcessSHA256 has_any (FileHash1))) or ((Process has_any (files2)) and (ActingProcessSHA256 has_any (FileHash2)))\n // Increase risk score if recent alerts for the host\n | join kind=leftouter (SecurityAlert\n | where ProviderName =~ \"MDATP\"\n | extend ThreatName = tostring(parse_json(ExtendedProperties).ThreatName)\n | mv-expand todynamic(Entities)\n | extend DvcId = tostring(parse_json(Entities).MdatpDeviceId)\n | where isnotempty(DvcId)\n // Higher risk score are for Defender alerts related to threat actor\n | extend AlertRiskScore = iif(ThreatName has_any (\"Backdoor:MSIL/ShellClient.A\", \"Backdoor:MSIL/ShellClient.A!dll\", \"Trojan:MSIL/Mimikatz.BA!MTB\"), 1.0, 0.5)\n | project DvcId, AlertRiskScore) on DvcId\n | extend AlertRiskScore = iif(isempty(AlertRiskScore), 0.0, AlertRiskScore)\n | extend timestamp = TimeGenerated, HostCustomEntity = Dvc, AccountCustomEntity = ActorUsername",
                "queryFrequency": "PT6H",
                "queryPeriod": "PT6H",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess",
                  "Execution"
                ],
                "techniques": [
                  "T1569",
                  "T1003"
                ],
                "templateVersion": "1.2.0",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/f9483e87-5ccf-4914-8f15-5dc6e1894066')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "30c8b802-ace1-4408-bc29-4c5c5afb49e1",
                "description": "This query looks for the Sdelete process being run recursively after being deployed to a host via GPO. Attackers could use this technique to deploy Sdelete to multiple host and delete data on them.\n  This query uses the Advanced Security Information Model. Parsers will need to be deployed before use: https://docs.microsoft.com/azure/sentinel/normalization",
                "displayName": "Sdelete deployed via GPO and run recursively (ASIM Version)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "ActorUsername",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "DvcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "Dvc",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "imProcess\n  | where EventType =~ \"ProcessCreated\"\n  | where Process endswith \"svchost.exe\"\n  | where CommandLine has \"-k GPSvcGroup\" or CommandLine has \"-s gpsvc\"\n  | extend timekey = bin(TimeGenerated, 1m)\n  | project timekey, ActingProcessId, Dvc\n  | join kind=inner (imProcess\n  | where EventType =~ \"ProcessCreated\"\n  | where Process =~ \"sdelete.exe\" or CommandLine has \"sdelete\"\n  | where ActingProcessName endswith \"svchost.exe\"\n  | where CommandLine has_all (\"-s\", \"-r\")\n  | extend timekey = bin(TimeGenerated, 1m)\n  ) on $left.ActingProcessId == $right.ParentProcessId, timekey, Dvc",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [
                  "T1485"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/69559a99-5851-4ffb-92cc-6ed7f11d02d3')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "The client at address {{SrcIpAddr}} generated more than {{threshold}} failures over a 5 minutes time window, which may indicate malicious activity.",
                  "alertDisplayNameFormat": "Excessive number of failed connections from {{SrcIpAddr}}"
                },
                "alertRuleTemplateName": "4902eddb-34f7-44a8-ac94-8486366e9494",
                "customDetails": {
                  "NumberOfDenies": "Count"
                },
                "description": "This rule identifies a single source that generates an excessive amount of failed connections. Modify the threshold to change the sensitivity of the rule: the higher the threshold, the less sensitive is the rule and less incidents will be generated.<br><br> \n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema",
                "displayName": "Excessive number of failed connections from a single source (ASIM Network Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let threshold = 5000;\n_Im_NetworkSession(eventresult='Failure')\n| summarize Count=count() by SrcIpAddr, bin(TimeGenerated,5m)\n| where Count > threshold\n| extend timestamp = TimeGenerated, threshold",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [
                  "T1499"
                ],
                "templateVersion": "1.2.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/1e57b789-5eca-48e9-aa90-264e96985bea')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "01e8ffff-dc0c-43fe-aa22-d459c4204553",
                "description": "Identifies callouts to Discord CDN addresses for risky file extensions. This detection will trigger when a callout for a risky file is made to a discord server that has only been seen once in your environment. Unique discord servers are identified using the server ID that is included in the request URL (DiscordServerId in query). Discord CDN has been used in multiple campaigns to download additional payloads.\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)",
                "displayName": "Discord CDN Risky File Download  (ASIM Web Session Schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "SourceUser",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SourceIP",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "RequestURL",
                        "identifier": "Url"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let discord=dynamic([\"cdn.discordapp.com\", \"media.discordapp.com\"]);\n  _Im_WebSession(url_has_any=discord, eventresult='Success')\n  | where Url has \"attachments\"\n  | extend DiscordServerId = extract(@\"\\/attachments\\/([0-9]+)\\/\", 1, Url)\n  | summarize dcount(Url), make_set(SrcUsername), make_set(SrcIpAddr), make_set(Url), min(TimeGenerated), max(TimeGenerated), make_set(EventResult) by DiscordServerId\n  | mv-expand set_SrcUsername to typeof(string), set_Url to typeof(string), set_EventResult to typeof(string), set_SrcIpAddr to typeof(string)\n  | summarize by DiscordServerId, dcount_Url, set_SrcUsername, min_TimeGenerated, max_TimeGenerated, set_EventResult, set_SrcIpAddr, set_Url\n  | project StartTime=min_TimeGenerated, EndTime=max_TimeGenerated, Result=set_EventResult, SourceUser=set_SrcUsername, SourceIP=set_SrcIpAddr, RequestURL=set_Url\n  | where RequestURL has_any (\".bin\",\".exe\",\".dll\",\".bin\",\".msi\")",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CommandAndControl"
                ],
                "techniques": [
                  "T1071"
                ],
                "templateVersion": "1.1.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/3fac13e7-ad82-4d9d-aded-8e98b1f88e65')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "The client at address {{SrcIpAddr}} accessed the URL {{Url}} that has the extension {{requestedFileExt}}. Downloading a file with this extension may be harmful and may indicate malicious activity.",
                  "alertDisplayNameFormat": "Client {{SrcIpAddr}} accessed a URL with potentially harmful extension {{requestedFileExt}}"
                },
                "alertRuleTemplateName": "09c49590-4e9d-4da9-a34d-17222d0c9e7e",
                "customDetails": {
                  "requestedFileName": "requestedFileName",
                  "requestedFileExt": "requestedFileExt"
                },
                "description": "This rule identifies a web request to a URL that holds a file type, including .ps1, .bat, .vbs, and .scr that can be harmful if downloaded. This rule uses the [Advanced Security Information Model (ASIM)](https://aka.ms/AboutASIM) and supports any web session source that complies with ASIM. To use this Analytics Rule, deploy the Advanced Security Information Model (ASIM).\n This analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM WebSession schema (ASIM WebSession Schema)",
                "displayName": "A client made a web request to a potentially harmful file (ASIM Web Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "SrcIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  },
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "Url",
                        "identifier": "Url"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "AlertPerResult"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let default_file_ext_blocklist=dynamic(['.ps1', '.vbs', '.bat', '.scr']);\nlet custom_file_ext_blocklist=toscalar(_GetWatchlist('RiskyFileTypes') | extend Extension=column_ifexists(\"Extension\",\"\") | where isnotempty(Extension) | summarize make_set(Extension));\nlet file_ext_blocklist = array_concat(default_file_ext_blocklist, custom_file_ext_blocklist);\n_Im_WebSession(url_has_any=file_ext_blocklist, eventresult='Success')\n| extend requestedFileName=tostring(split(tostring(parse_url(Url)[\"Path\"]),'/')[-1])\n| extend requestedFileExt=extract('\\\\.\\\\w+$', 1, requestedFileName, typeof(string))\n| where requestedFileExt in (file_ext_blocklist)\n| summarize LastAttemptTime=max(TimeGenerated), NumFailedAttempts=count() by SrcIpAddr, requestedFileName, Url, requestedFileExt, User\n| extend IPCustomEntity = SrcIpAddr, UrlCustomEntity=Url",
                "queryFrequency": "PT10M",
                "queryPeriod": "PT10M",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b0cc08ec-98aa-4cf1-b5b5-197afa3b7ff3')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "The source address {{SrcIpAddr}} of a web request matched a known indicator of compromise of {{ThreatType}}. Consult the threat intelligence blade for more information on the indicator.",
                  "alertDisplayNameFormat": "The IP {{SrcIpAddr}} of a web request matched an IoC"
                },
                "alertRuleTemplateName": "e2559891-383c-4caf-ae67-55a008b9f89e",
                "customDetails": {
                  "ActivityGroupNames": "ActivityGroupNames",
                  "IndicatorId": "IndicatorId",
                  "IoCConfidenceScore": "ConfidenceScore",
                  "ThreatType": "ThreatType",
                  "IoCExpirationTime": "ExpirationDateTime",
                  "IoCDescription": "Description",
                  "EventTime": "imNWS_TimeGenerated"
                },
                "description": "This rule identifies Web Sessions for which the source IP address is a known IoC. <br><br>This rule uses the [Advanced Security Information Model (ASIM)](https://aka.ms/AboutASIM) and supports any web session source that complies with ASIM.",
                "displayName": "(Preview) TI map IP entity to Web Session Events (ASIM Web Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "DstIpAddr",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let HAS_ANY_MAX = 10000;\nlet dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet IoCList = materialize(externaldata(TimeGenerated:datetime,IoC:string,IoC_Type:string,ExpirationDateTime:datetime,Description:string,Action:string, ConfidenceScore:real, ThreatType:string, Active:string,Type:string, TrafficLightProtocolLevel:string, ActivityGroupNames:string)[@\"https://raw.githubusercontent.com/microsoft/mstic/master/RapidReleaseTI/Indicators.csv\"] with(format=\"csv\", ignoreFirstRecord=True));\nlet IP_TI= (union isfuzzy=true\n(ThreatIntelligenceIndicator\n| where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n| where Active == true\n// As there is potentially more than 1 indicator type for matching IP, taking NetworkIP first, then others if that is empty.\n// Taking the first non-empty value based on potential IOC match availability\n| extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,\"NO_IP\")\n// Picking up only IOC's that contain the entities we want\n| where TI_ipEntity != \"NO_IP\"\n//Exclude local addresses, using the ipv4_is_private operator\n| where ipv4_is_private(TI_ipEntity) == false and  TI_ipEntity !startswith \"fe80\" and TI_ipEntity !startswith \"::\" and TI_ipEntity !startswith \"127.\"\n),\n(IoCList\n| where IoC_Type =~ 'IP'\n| where ExpirationDateTime > now()\n| summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IoC\n| where Active =~ 'True'\n| extend TI_ipEntity = IoC\n| project-away  IoC_Type\n)\n);\nlet IP_TI_list=toscalar(IP_TI | summarize NIoCs= dcount(TI_ipEntity), IoCs=make_set(TI_ipEntity) \n  | project IoCs=iff(NIoCs > HAS_ANY_MAX, dynamic([]), IoCs )  );\nIP_TI\n// using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique (\n    _Im_WebSession (starttime=ago(dt_lookBack), srcipaddr_has_any_prefix=IP_TI_list)\n    | where isnotempty(SrcIpAddr)\n    // renaming time column so it is clear the log this came from\n    | extend imNWS_TimeGenerated = TimeGenerated\n)\non $left.TI_ipEntity == $right.SrcIpAddr\n| where imNWS_TimeGenerated < ExpirationDateTime\n| summarize imNWS_TimeGenerated = arg_max(imNWS_TimeGenerated , *) by IndicatorId, DstIpAddr, IoC\n| project imNWS_TimeGenerated, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore,\nTI_ipEntity, Dvc, SrcIpAddr, DstIpAddr, Type\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [],
                "templateVersion": "1.1.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/9826d7df-5b9b-42ad-85c4-defc25780306')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertDetailsOverride": {
                  "alertDescriptionFormat": "The {{IoCDirection}} address {{IoCIP}} of a network session  matched a known indicator of compromise of {{ThreatType}}. Consult the threat intelligence blead for more information on the indicator.",
                  "alertDisplayNameFormat": "A network session {{IoCDirection}} address {{IoCIP}} matched an IoC."
                },
                "alertRuleTemplateName": "e2399891-383c-4caf-ae67-68a008b9f89e",
                "customDetails": {
                  "ActivityGroupNames": "ActivityGroupNames",
                  "IndicatorId": "IndicatorId",
                  "ThreatType": "ThreatType",
                  "IoCConfidenceScore": "ConfidenceScore",
                  "IoCExpirationTime": "ExpirationDateTime",
                  "IoCDescription": "Description",
                  "IoCIPDirection": "IoCDirection",
                  "EventEndTime": "imNWS_maxtime",
                  "EventStartTime": "imNWS_mintime"
                },
                "description": "This rule identifies a match Network Sessions for which the source or destination IP address is a known IoC. <br><br>\nThis analytic rule uses [ASIM](https://aka.ms/AboutASIM) and supports any built-in or custom source that supports the ASIM NetworkSession schema",
                "displayName": "TI map IP entity to Network Session Events (ASIM Network Session schema)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IoCIP",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let dt_lookBack = 1h;\nlet ioc_lookBack = 14d;\nlet IP_TI = materialize (\n  ThreatIntelligenceIndicator\n  | where TimeGenerated >= ago(ioc_lookBack) and ExpirationDateTime > now()\n  | summarize LatestIndicatorTime = arg_max(TimeGenerated, *) by IndicatorId\n  | where Active == true\n  | extend TI_ipEntity = coalesce(NetworkIP, NetworkDestinationIP, NetworkSourceIP,EmailSourceIpAddress,\"NO_IP\")\n  | where TI_ipEntity != \"NO_IP\"\n);\nIP_TI\n  // using innerunique to keep perf fast and result set low, we only need one match to indicate potential malicious activity that needs to be investigated\n| join kind=innerunique \n(\n  _Im_NetworkSession (starttime=ago(dt_lookBack))\n  | where isnotempty(SrcIpAddr)\n  | summarize imNWS_mintime=min(TimeGenerated), imNWS_maxtime=max(TimeGenerated) by SrcIpAddr, DstIpAddr, Dvc, EventProduct, EventVendor  \n  | lookup (IP_TI | project TI_ipEntity, Active) on $left.SrcIpAddr == $right.TI_ipEntity\n  | project-rename SrcMatch = Active\n  | lookup (IP_TI | project TI_ipEntity, Active) on $left.DstIpAddr == $right.TI_ipEntity\n  | project-rename DstMatch = Active\n  | where SrcMatch or DstMatch\n  | extend \n      IoCIP = iff(SrcMatch, SrcIpAddr, DstIpAddr),\n      IoCDirection = iff(SrcMatch, \"Source\", \"Destination\")\n)on $left.TI_ipEntity == $right.IoCIP\n| where imNWS_mintime < ExpirationDateTime\n| project imNWS_mintime, imNWS_maxtime, Description, ActivityGroupNames, IndicatorId, ThreatType, ExpirationDateTime, ConfidenceScore, SrcIpAddr, DstIpAddr, IoCDirection, IoCIP, Dvc, EventVendor, EventProduct\n",
                "queryFrequency": "PT1H",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Impact"
                ],
                "techniques": [],
                "templateVersion": "1.2.4",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b279d270-77fb-4915-838d-b8f1ecbd9f88')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "09ec8fa2-b25f-4696-bfae-05a7b85d7b9e",
                "description": "This query searches for successful user logins from different countries within 3 hours.\n To use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimAuthentication)",
                "displayName": "User login from different countries within 3 hours (Uses Authentication Normalization)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let timeframe = ago(3h);\nlet threshold = 2;\nimAuthentication\n| where TimeGenerated > timeframe\n| where EventType=='Logon' and EventResult=='Success'\n| where isnotempty(SrcGeoCountry)\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), Vendors=make_set(EventVendor), Products=make_set(EventProduct)\n  , NumOfCountries = dcount(SrcGeoCountry)\n  by TargetUserId, TargetUsername, TargetUserType\n| where NumOfCountries >= threshold\n| extend timestamp = StartTime, AccountCustomEntity = TargetUsername",
                "queryFrequency": "PT3H",
                "queryPeriod": "PT3H",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.2.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/b2044a93-4bce-42d2-8f4e-72710a0fb628')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "bc5ffe2a-84d6-48fe-bc7b-1055100469bc",
                "description": "Identifies SolarWinds SUNBURST and SUPERNOVA backdoor file hash IOCs in File Events\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimFileEvent)\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f",
                "displayName": "SUNBURST and SUPERNOVA backdoor hashes (Normalized File Events)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "FileHash",
                    "fieldMappings": [
                      {
                        "columnName": "AlgorithmCustomEntity",
                        "identifier": "Algorithm"
                      },
                      {
                        "columnName": "FileHashCustomEntity",
                        "identifier": "Value"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let SunburstMD5=dynamic([\"b91ce2fa41029f6955bff20079468448\",\"02af7cec58b9a5da1c542b5a32151ba1\",\"2c4a910a1299cdae2a4e55988a2f102e\",\"846e27a652a5e1bfbd0ddd38a16dc865\",\"4f2eb62fa529c0283b28d05ddd311fae\"]);\nlet SupernovaMD5=\"56ceb6d0011d87b6e4d7023d7ef85676\";\nimFileEvent\n| where TargetFileMD5 in(SunburstMD5) or TargetFileMD5 in(SupernovaMD5)\n| extend\n    timestamp = TimeGenerated,\n    AccountCustomEntity = User, \n    HostCustomEntity = DvcHostname,\n    FileHashCustomEntity = TargetFileMD5,\n    AlgorithmCustomEntity = \"MD5\"",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution",
                  "Persistence",
                  "InitialAccess"
                ],
                "techniques": [
                  "T1195",
                  "T1059",
                  "T1546"
                ],
                "templateVersion": "1.0.5",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/68471e35-39b9-4489-8d80-dd9409397ce8')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "cfc1ae62-db63-4a3e-b88b-dc04030c2257",
                "description": "This detection uses Security events from the \"AD FS Auditing\" provider to detect suspicious object identifiers (OIDs) as part EventID 501 and specifically part of the Enhanced Key Usage attributes.\nThis query checks to see if you have any new OIDs in the last hour that have not been seen in the previous day. New OIDs should be validated and OIDs that are very long, as indicated\nby the OID_Length field, could also be an indicator of malicious activity.\nIn order to use this query you need to enable AD FS auditing on the AD FS Server.\nReferences:\nhttps://www.microsoft.com/security/blog/2022/08/24/magicweb-nobeliums-post-compromise-trick-to-authenticate-as-anyone/\nhttps://docs.microsoft.com/windows-server/identity/ad-fs/troubleshooting/ad-fs-tshoot-logging\n",
                "displayName": "AD FS Abnormal EKU object identifier attribute",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "Computer",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "// change the starttime value for a longer period of known OIDs\nlet starttime = 1d;\n// change the lookback value for a longer period of lookback for suspicious/abnormal\nlet lookback = 1h;\nlet OIDList = SecurityEvent\n| where TimeGenerated >= ago(starttime)\n| where EventSourceName == 'AD FS Auditing'\n| where EventID == 501\n| where EventData has '/eku'\n| extend OIDs = extract_all(@\"<Data>([\\d+\\.]+)</Data>\", EventData)\n| mv-expand OIDs\n| extend OID = tostring(OIDs)\n| extend OID_Length = strlen(OID)\n| project TimeGenerated, Computer, EventSourceName, EventID, OID, OID_Length, EventData\n;\nOIDList\n| where TimeGenerated >= ago(lookback)\n| join kind=leftanti (\nOIDList\n| where TimeGenerated between (ago(starttime) .. ago(lookback))\n| summarize by OID\n) on OID",
                "queryFrequency": "PT1H",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1552"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/1f53e419-aeff-49a8-be2d-af2db46de642')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "631d02df-ab51-46c1-8d72-32d0cfec0720",
                "description": "Identifies suspicious child processes of SolarWinds.Orion.Core.BusinessLayer.dll that may be evidence of the SUNBURST backdoor\nReferences:\n- https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html\n- https://gist.github.com/olafhartong/71ffdd4cab4b6acd5cbcd1a0691ff82f\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)",
                "displayName": "SUNBURST suspicious SolarWinds child processes (Normalized Process Events)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "FileHash",
                    "fieldMappings": [
                      {
                        "columnName": "AlgorithmCustomEntity",
                        "identifier": "Algorithm"
                      },
                      {
                        "columnName": "FileHashCustomEntity",
                        "identifier": "Value"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let excludeProcs = dynamic([@\"\\SolarWinds\\Orion\\APM\\APMServiceControl.exe\", @\"\\SolarWinds\\Orion\\ExportToPDFCmd.Exe\", @\"\\SolarWinds.Credentials\\SolarWinds.Credentials.Orion.WebApi.exe\", @\"\\SolarWinds\\Orion\\Topology\\SolarWinds.Orion.Topology.Calculator.exe\", @\"\\SolarWinds\\Orion\\Database-Maint.exe\", @\"\\SolarWinds.Orion.ApiPoller.Service\\SolarWinds.Orion.ApiPoller.Service.exe\", @\"\\Windows\\SysWOW64\\WerFault.exe\"]);\nimProcessCreate\n| where Process hassuffix 'solarwinds.businesslayerhost.exe'\n| where not(Process has_any (excludeProcs))\n| extend\n    timestamp = TimeGenerated,\n    AccountCustomEntity = ActorUsername,\n    HostCustomEntity = User,\n    AlgorithmCustomEntity = \"MD5\",\n    FileHashCustomEntity = TargetProcessMD5 // Change to *hash* once implemented",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Execution",
                  "Persistence"
                ],
                "techniques": [],
                "templateVersion": "1.1.3",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/a2e8076e-5b43-425a-945e-4966da27799c')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "95002681-4ecb-4da3-9ece-26d7e5feaa33",
                "description": "Identifies IPs with failed attempts to sign in to one or more disabled accounts signed in successfully to another account.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimAuthentication)",
                "displayName": "Sign-ins from IPs that attempt sign-ins to disabled accounts (Uses Authentication Normalization)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "imAuthentication\n| where EventResult =='Failure'\n| where EventResultDetails == 'User disabled'\n| summarize StartTime=min(EventStartTime), EndTime=max(EventEndTime), disabledAccountLoginAttempts = count()\n      , disabledAccountsTargeted = dcount(TargetUsername), disabledAccountSet = make_set(TargetUsername)\n      , applicationsTargeted = dcount(TargetAppName)\n      , applicationSet = make_set(TargetAppName) \n      by SrcDvcIpAddr, Type\n| order by disabledAccountLoginAttempts desc\n| join kind=leftouter \n    (\n    // Consider these IPs suspicious - and alert any related  successful sign-ins\n    imAuthentication\n    | where EventResult=='Success'\n    | summarize successfulAccountSigninCount = dcount(TargetUsername), successfulAccountSigninSet = makeset(TargetUsername, 15) by SrcDvcIpAddr, Type\n    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe\n    | where successfulAccountSigninCount < 100\n    )\n    on SrcDvcIpAddr\n| where isnotempty(successfulAccountSigninCount)\n| project StartTime, EndTime, SrcDvcIpAddr, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet, \nsuccessfulAccountSigninCount, successfulAccountSigninSet, Type\n| order by disabledAccountLoginAttempts\n| extend timestamp = StartTime, IPCustomEntity = SrcDvcIpAddr",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess",
                  "Persistence"
                ],
                "techniques": [
                  "T1078",
                  "T1098"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/dcba42b1-aace-42f8-8d3e-acfb4d89f4de')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "6a2e2ff4-5568-475e-bef2-b95f12b9367b",
                "description": "This query searches for failed attempts to log in from more than 15 various users within a 5 minute timeframe from the same source. This is a potential indication of a password spray attack\n To use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimAuthentication)",
                "displayName": "Potential Password Spray Attack (Uses Authentication Normalization)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPCustomEntity",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let FailureThreshold = 15;\nimAuthentication\n| where EventType== 'Logon' and  EventResult== 'Failure'\n// reason: creds \n| where EventResultDetails in ('No such user or password', 'Incorrect password')\n| summarize UserCount=dcount(TargetUserId), Vendors=make_set(EventVendor), Products=make_set(EventVendor)\n  , Users = make_set(TargetUserId,100) \n    by SrcDvcIpAddr, SrcGeoCountry, bin(TimeGenerated, 5m)\n| where UserCount > FailureThreshold\n| extend timestamp = TimeGenerated, IPCustomEntity = SrcDvcIpAddr",
                "queryFrequency": "PT1H",
                "queryPeriod": "PT1H",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1110"
                ],
                "templateVersion": "1.1.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/e1ab8b56-fd2a-4af7-b0a7-dee14b7948c4')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "bdf04f58-242b-4729-b376-577c4bdf5d3a",
                "description": "This query idenifies when rundll32.exe executes a specific set of inline VBScript commands\nReferences: https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware/\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)",
                "displayName": "Midnight Blizzard - suspicious rundll32.exe execution of vbscript (Normalized Process Events)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "imProcessCreate\n| where Process hassuffix 'rundll32.exe'\n| where CommandLine  has_any ('Execute','RegRead','window.close')\n| project TimeGenerated, Dvc, User, Process, CommandLine, ActingProcessName, EventVendor, EventProduct\n| extend timestamp = TimeGenerated, HostCustomEntity = Dvc, AccountCustomEntity = User",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence"
                ],
                "techniques": [
                  "T1547"
                ],
                "templateVersion": "1.1.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/fc4cba48-4946-4813-8493-9106d3dfc2a9')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "61988db3-0565-49b5-b8e3-747195baac6e",
                "description": "Identifies malware that has been hidden in the recycle bin.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimProcessEvent)",
                "displayName": "Malware in the recycle bin (Normalized Process Events)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Host",
                    "fieldMappings": [
                      {
                        "columnName": "HostCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let procList = dynamic([\"cmd.exe\",\"ftp.exe\",\"schtasks.exe\",\"powershell.exe\",\"rundll32.exe\",\"regsvr32.exe\",\"msiexec.exe\"]);  \nimProcessCreate\n| where CommandLine has \"recycler\"\n| where Process has_any (procList)\n| extend FileName = tostring(split(Process, '\\\\')[-1])\n| where FileName in~ (procList)\n| project StartTimeUtc = TimeGenerated, Dvc, User, Process, FileName, CommandLine, ActingProcessName, EventVendor, EventProduct\n| extend timestamp = StartTimeUtc, AccountCustomEntity = User, HostCustomEntity = Dvc",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "DefenseEvasion"
                ],
                "techniques": [
                  "T1564"
                ],
                "templateVersion": "1.2.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/59a1c412-43aa-4405-89bc-bd5358c4341d')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "93a25f10-593d-4c57-a752-a8a75f031425",
                "description": "This query detects users retrieving significantly more records from Dynamics 365 than they have in the past 2 weeks. This could indicate potentially unauthorized access to data within Dynamics 365.",
                "displayName": "Dynamics 365 - User Bulk Retrieval Outside Normal Activity",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let baseline_time = 14d;\nlet detection_time = 1d;\nDynamics365Activity\n| where TimeGenerated between(ago(baseline_time)..ago(detection_time-1d))\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| where Message =~ \"RetrieveMultiple\"\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))\n| summarize sum(QueryCount) by UserId\n| extend HistoricalBaseline = sum_QueryCount\n| join (Dynamics365Activity\n| where TimeGenerated > ago(detection_time)\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| where Message =~ \"RetrieveMultiple\"\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))\n| summarize sum(QueryCount) by UserId\n| extend CurrentExportRate = sum_QueryCount) on UserId\n| where CurrentExportRate > HistoricalBaseline\n| project UserId, HistoricalBaseline, CurrentExportRate\n| join kind=inner(Dynamics365Activity\n| where TimeGenerated > ago(detection_time)\n| extend Message = tostring(split(OriginalObjectId, ' ')[0])\n| where Message =~ \"RetrieveMultiple\"\n| extend numQueryCount = todouble(QueryResults)\n| extend QueryCount = iif(QueryResults contains \",\", todouble(countof(tostring(QueryResults), ',') + 1), numQueryCount)\n| extend QueryCount = iif(isnotempty(QueryCount), QueryCount, double(1))) on UserId\n| project TimeGenerated, UserId, QueryCount, UserAgent, Message, ClientIP, HistoricalBaseline, CurrentExportRate, CorrelationId, CrmOrganizationUniqueName, Query\n| summarize QuerySizes = make_set(QueryCount), MostRecentQuery = max(TimeGenerated), IPs = make_set(ClientIP), UserAgents = make_set(UserAgent), make_set(Query) by UserId, CrmOrganizationUniqueName, HistoricalBaseline, CurrentExportRate\n| extend timestamp = MostRecentQuery, AccountCustomEntity = UserId",
                "queryFrequency": "P1D",
                "queryPeriod": "P14D",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Collection"
                ],
                "techniques": [
                  "T1530"
                ],
                "templateVersion": "1.0.1",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/0ff5d36e-84d1-4244-b4dc-e52e61e47772')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "a6c435a2-b1a0-466d-b730-9f8af69262e8",
                "customDetails": {
                  "IpAddresses": "IpAddresses",
                  "ReportedBy": "ReportedBy"
                },
                "description": "Identifies evidence of brute force activity against a user based on multiple authentication failures \nand at least one successful authentication within a given time window. Note that the query does not enforce any sequence,\nand does not require the successful authentication to occur last.\nThe default failure threshold is 10, success threshold is 1, and the default time window is 20 minutes.\nTo use this analytics rule, make sure you have deployed the [ASIM normalization parsers](https://aka.ms/ASimAuthentication)",
                "displayName": "Brute force attack against user credentials (Uses Authentication Normalization)",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "TargetUsername",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let failureCountThreshold = 10;\nlet successCountThreshold = 1;\n// let authenticationWindow = 20m; // Implicit in the analytic rule query period \nimAuthentication\n| where TargetUserType != \"NonInteractive\"\n| summarize \n      StartTime = min(TimeGenerated), \n      EndTime = max(TimeGenerated), \n      IpAddresses = make_set (SrcDvcIpAddr, 100),\n      ReportedBy = make_set (strcat (EventVendor, \"/\", EventProduct), 100),\n      FailureCount = countif(EventResult=='Failure'),\n      SuccessCount = countif(EventResult=='Success')\n  by \n      TargetUserId, TargetUsername, TargetUserType \n| where FailureCount >= failureCountThreshold and SuccessCount >= successCountThreshold\n| extend\n      IpAddresses = strcat_array(IpAddresses, \", \"), \n      ReportedBy = strcat_array(ReportedBy, \", \")",
                "queryFrequency": "PT20M",
                "queryPeriod": "PT20M",
                "severity": "Medium",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [
                  "T1110"
                ],
                "templateVersion": "1.2.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/e2a2ddc0-babc-453e-b4b7-4217dfbaaa3c')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "017e095a-94d8-430c-a047-e51a11fb737b",
                "description": "Detects a URL being added to an application where the domain is not one that is associated with the tenant.\n  The query uses domains seen in sign in logs to determine if the domain is associated with the tenant.\n  Applications associated with URLs not controlled by the organization can pose a security risk.\n  Ref: https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-applications#application-configuration-changes",
                "displayName": "URL Added to Application from Unknown Domain",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "URL",
                    "fieldMappings": [
                      {
                        "columnName": "AddedUrls",
                        "identifier": "Url"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AddedBy",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "ipAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let domains =\n  SigninLogs\n  | where ResultType == 0\n  | extend domain = split(UserPrincipalName, \"@\")[1]\n  | extend domain = tostring(split(UserPrincipalName, \"@\")[1])\n  | summarize by tolower(tostring(domain));\n  AuditLogs\n  | where Category =~ \"ApplicationManagement\"\n  | where Result =~ \"success\"\n  | where OperationName =~ 'Update Application'\n  | mv-expand TargetResources\n  | mv-expand TargetResources.modifiedProperties\n  | where TargetResources_modifiedProperties.displayName =~ \"AppAddress\"\n  | extend Key = tostring(TargetResources_modifiedProperties.displayName)\n  | extend NewValue = TargetResources_modifiedProperties.newValue\n  | extend OldValue = TargetResources_modifiedProperties.oldValue\n  | where isnotempty(Key) and isnotempty(NewValue)\n  | project-reorder Key, NewValue, OldValue\n  | extend NewUrls = extract_all('\"Address\":([^,]*)', tostring(NewValue))\n  | extend OldUrls = extract_all('\"Address\":([^,]*)', tostring(OldValue))\n  | extend AddedUrls = set_difference(NewUrls, OldUrls)\n  | where array_length(AddedUrls) > 0\n  | extend UserAgent = iif(tostring(AdditionalDetails[0].key) == \"User-Agent\", tostring(AdditionalDetails[0].value), \"\")\n  | extend AddingUser = iif(isnotempty(tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName)) , tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName), \"\")\n  | extend AddingApp = iif(isnotempty(tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName)) , tostring(parse_json(tostring(InitiatedBy.app)).servicePrincipalName), \"\")\n  | extend AddedBy = iif(isnotempty(AddingUser), AddingUser, AddingApp)\n  | project-away AddingApp, AddingUser\n  | extend AppDisplayName = tostring(TargetResources.displayName)\n  | extend ipAddress = tostring(parse_json(tostring(InitiatedBy.user)).ipAddress)\n  | where isnotempty(AddedUrls)\n  | mv-expand AddedUrls\n  | extend AddedUrls = trim(@'\"', tostring(AddedUrls))\n  | extend Domain = extract(\"^(?:https?:\\\\/\\\\/)?(?:[^@\\\\/\\\\n]+@)?(?:www\\\\.)?([^:\\\\/?\\\\n]+)/\", 1, replace_string(tolower(AddedUrls), '\"', \"\"))\n  | where isnotempty(Domain)\n  | extend Domain = strcat(split(Domain, \".\")[-2], \".\", split(Domain, \".\")[-1])\n  | where Domain !in (domains)\n  | project-reorder TimeGenerated, AppDisplayName, AddedUrls, AddedBy, UserAgent, ipAddress",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "High",
                "suppressionDuration": "PT5H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence",
                  "PrivilegeEscalation"
                ],
                "techniques": [
                  "T1078"
                ],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/a52e87da-b09d-4df8-8471-7894be247865')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "b09795c9-8dce-47ab-8f75-5a4afb78ef0c",
                "description": "Identifies when a new privileged role is assigned to a user.  Any account eligible for a role is now being given privileged access. If the assignment is unexpected or into a role that isn't the responsibility of the account holder, investigate.\nRef : https://docs.microsoft.com/azure/active-directory/fundamentals/security-operations-privileged-accounts#things-to-monitor-1",
                "displayName": "Threat Essentials - User Assigned Privileged Role",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Initiator",
                        "identifier": "FullName"
                      }
                    ]
                  },
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "AccountCustomEntity",
                        "identifier": "FullName"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where Category =~ \"RoleManagement\"\n| where AADOperationType in (\"Assign\", \"AssignEligibleRole\")\n| where ActivityDisplayName has_any (\"Add eligible member to role\", \"Add member to role\")\n| mv-expand TargetResources\n| mv-expand TargetResources.modifiedProperties\n| extend displayName_ = tostring(TargetResources_modifiedProperties.displayName)\n| where displayName_ =~ \"Role.DisplayName\"\n| extend RoleName = tostring(parse_json(tostring(TargetResources_modifiedProperties.newValue)))\n| where RoleName contains \"Admin\"\n| extend InitiatingApp = tostring(parse_json(tostring(InitiatedBy.app)).displayName)\n| extend Initiator = iif(isnotempty(InitiatingApp), InitiatingApp, tostring(parse_json(tostring(InitiatedBy.user)).userPrincipalName))\n| extend Target = tostring(TargetResources.userPrincipalName)\n| summarize by bin(TimeGenerated, 1h), OperationName,  RoleName, Target, Initiator, Result\n| extend AccountCustomEntity = Target\n",
                "queryFrequency": "PT2H",
                "queryPeriod": "PT2H",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "Persistence"
                ],
                "techniques": [],
                "templateVersion": "1.0.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/92690469-eb2d-4440-b94b-f611a2a39b5b')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "NRT",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "8540c842-5bbc-4a24-9fb2-a836c0e55a51",
                "description": "This will alert when a user or application modifies the federation settings on the domain or Update domain authentication from Managed to Federated.\nFor example, this alert will trigger when a new Active Directory Federated Service (ADFS) TrustedRealm object, such as a signing certificate, is added to the domain.\nModification to domain federation settings should be rare. Confirm the added or modified target domain/URL is legitimate administrator behavior.\nTo understand why an authorized user may update settings for a federated domain in Office 365, Azure, or Intune, see: https://docs.microsoft.com/office365/troubleshoot/active-directory/update-federated-domain-office-365.\nFor details on security realms that accept security tokens, see the ADFS Proxy Protocol (MS-ADFSPP) specification: https://docs.microsoft.com/openspecs/windows_protocols/ms-adfspp/e7b9ea73-1980-4318-96a6-da559486664b.\nFor further information on AuditLogs please see https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-audit-activities.",
                "displayName": "NRT Modified domain federation trust settings",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "Account",
                    "fieldMappings": [
                      {
                        "columnName": "Name",
                        "identifier": "Name"
                      },
                      {
                        "columnName": "UPNSuffix",
                        "identifier": "UPNSuffix"
                      }
                    ]
                  },
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "InitiatingIpAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "AuditLogs\n| where OperationName =~ \"Set federation settings on domain\" or OperationName =~ \"Set domain authentication\"\n//| where Result =~ \"success\"   // commenting out, as it may be interesting to capture failed attempts\n| mv-expand TargetResources\n| extend modifiedProperties = parse_json(TargetResources).modifiedProperties\n| mv-apply Property = modifiedProperties on \n  (\n      where Property.displayName =~ \"LiveType\"\n      | extend targetDisplayName = tostring(Property.displayName),\n               NewDomainValue = tostring(Property.newValue)\n  )\n| extend Federated = iif(OperationName =~ \"Set domain authentication\", iif(NewDomainValue has \"Federated\", True, False), True)\n| where Federated == True\n| mv-expand AdditionalDetails\n| mv-apply AdditionalDetail = AdditionalDetails on \n  (\n      where AdditionalDetail.key =~ \"User-Agent\"\n      | extend UserAgent = tostring(AdditionalDetail.value)\n  )\n| extend InitiatingUserOrApp = iff(isnotempty(InitiatedBy.user.userPrincipalName),tostring(InitiatedBy.user.userPrincipalName), tostring(InitiatedBy.app.displayName))\n| extend InitiatingIpAddress = iff(isnotempty(InitiatedBy.user.ipAddress), tostring(InitiatedBy.user.ipAddress), tostring(InitiatedBy.app.ipAddress))\n| project-reorder TimeGenerated, OperationName, InitiatingUserOrApp, AADOperationType, targetDisplayName, Result, InitiatingIpAddress, UserAgent, CorrelationId, TenantId, AADTenantId\n| extend Name = tostring(split(InitiatingUserOrApp,'@',0)[0]), UPNSuffix = tostring(split(InitiatingUserOrApp,'@',1)[0])\n",
                "severity": "High",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "CredentialAccess"
                ],
                "techniques": [],
                "templateVersion": "1.0.1"
              }
            },
            {
              "name": "[concat(parameters('Workspace'),'/Microsoft.SecurityInsights/9e72da12-e155-44ba-acf4-69ba5966575c')]",
              "type": "Microsoft.OperationalInsights/workspaces/providers/alertRules",
              "kind": "Scheduled",
              "apiVersion": "2022-09-01-preview",
              "properties": {
                "alertRuleTemplateName": "500c103a-0319-4d56-8e99-3cec8d860757",
                "description": "Identifies IPs with failed attempts to sign in to one or more disabled accounts using the IP through which successful signins from other accounts have happened.\nThis could indicate an attacker who obtained credentials for a list of accounts and is attempting to login with those accounts, some of which may have already been disabled.\nReferences: https://docs.microsoft.com/azure/active-directory/reports-monitoring/reference-sign-ins-error-codes\n50057 - User account is disabled. The account has been disabled by an administrator.",
                "displayName": "Sign-ins from IPs that attempt sign-ins to disabled accounts",
                "enabled": true,
                "entityMappings": [
                  {
                    "entityType": "IP",
                    "fieldMappings": [
                      {
                        "columnName": "IPAddress",
                        "identifier": "Address"
                      }
                    ]
                  }
                ],
                "eventGroupingSettings": {
                  "aggregationKind": "SingleAlert"
                },
                "incidentConfiguration": {
                  "createIncident": true,
                  "groupingConfiguration": {
                    "enabled": false,
                    "groupByAlertDetails": [],
                    "groupByCustomDetails": [],
                    "groupByEntities": [],
                    "lookbackDuration": "PT5H",
                    "matchingMethod": "AllEntities",
                    "reopenClosedIncident": false
                  }
                },
                "query": "let aadFunc = (tableName:string){\ntable(tableName)\n| where ResultType == \"50057\"\n| where ResultDescription =~ \"User account is disabled. The account has been disabled by an administrator.\"\n| summarize StartTime = min(TimeGenerated), EndTime = max(TimeGenerated), disabledAccountLoginAttempts = count(),\n            disabledAccountsTargeted = dcount(UserPrincipalName), applicationsTargeted = dcount(AppDisplayName), disabledAccountSet = make_set(UserPrincipalName,15),\n            applicationSet = make_set(AppDisplayName,15) by IPAddress, Type\n| order by disabledAccountLoginAttempts desc\n| join kind= leftouter (\n    // Consider these IPs suspicious - and alert any related  successful sign-ins\n    table(tableName)\n    | where ResultType == 0\n    | summarize successfulAccountSigninCount = dcount(UserPrincipalName), successfulAccountSigninSet = make_set(UserPrincipalName,15) by IPAddress, Type\n    // Assume IPs associated with sign-ins from 100+ distinct user accounts are safe\n    | where successfulAccountSigninCount < 100\n) on IPAddress\n// IPs from which attempts to authenticate as disabled user accounts originated, and had a non-zero success rate for some other account\n| where isnotempty(successfulAccountSigninCount)\n| project StartTime, EndTime, IPAddress, disabledAccountLoginAttempts, disabledAccountsTargeted, disabledAccountSet, applicationSet,\nsuccessfulAccountSigninCount, successfulAccountSigninSet, Type\n| order by disabledAccountLoginAttempts\n| extend timestamp = StartTime\n};\nlet aadSignin = aadFunc(\"SigninLogs\");\nlet aadNonInt = aadFunc(\"AADNonInteractiveUserSignInLogs\");\nunion isfuzzy=true aadSignin, aadNonInt\n",
                "queryFrequency": "P1D",
                "queryPeriod": "P1D",
                "severity": "Medium",
                "suppressionDuration": "PT1H",
                "suppressionEnabled": false,
                "tactics": [
                  "InitialAccess",
                  "Persistence"
                ],
                "techniques": [
                  "T1078",
                  "T1098"
                ],
                "templateVersion": "1.1.2",
                "triggerOperator": "GreaterThan",
                "triggerThreshold": 0
              }
            }
          ]
        }
      }
    }
  ],
  "outputs": {}
}
